import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.30.0';

// Initialize Supabase client
const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const supabase = createClient(supabaseUrl, supabaseKey);

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Telegram Bot Token
const TELEGRAM_BOT_TOKEN = Deno.env.get('TELEGRAM_BOT_TOKEN');

// Telegram message interface
interface TelegramMessage {
  message_id: number;
  from: {
    id: number;
    is_bot: boolean;
    first_name: string;
    last_name?: string;
    language_code?: string;
  };
  chat: {
    id: number;
    first_name: string;
    last_name?: string;
    type: string;
  };
  date: number;
  text?: string;
  entities?: Array<{
    offset: number;
    length: number;
    type: string;
  }>;
}

interface TelegramUpdate {
  update_id: number;
  message?: TelegramMessage;
}

// Send message to Telegram
async function sendTelegramMessage(chatId: number, text: string) {
  try {
    const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        text: text,
        parse_mode: 'HTML'
      }),
    });

    if (!response.ok) {
      console.error('Failed to send Telegram message:', await response.text());
    }
  } catch (error) {
    console.error('Error sending Telegram message:', error);
  }
}

// Get cities from cache
async function getCitiesFromCache() {
  try {
    const { data, error } = await supabase
      .from('cities_cache')
      .select('*')
      .eq('is_active', true);
    
    if (error) {
      console.error('Error fetching cities:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Exception fetching cities:', error);
    return [];
  }
}

// Get regions by city
async function getRegionsByCity(cityId: number) {
  try {
    const { data, error } = await supabase
      .from('regions_cache')
      .select('*')
      .eq('city_id', cityId)
      .eq('is_active', true);
    
    if (error) {
      console.error('Error fetching regions:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Exception fetching regions:', error);
    return [];
  }
}

// Normalize Arabic text
function normalizeArabic(text: string): string {
  if (!text) return '';
  
  return text
    .replace(/[\u064B-\u0652]/g, '') // Remove diacritics
    .replace(/[ÿ•ÿ£ÿ¢]/g, 'ÿß') // Normalize alef
    .replace(/ÿ©/g, 'Ÿá') // Normalize teh marbuta
    .replace(/Ÿä/g, 'Ÿä') // Normalize yeh
    .replace(/\s+/g, ' ') // Normalize spaces
    .trim()
    .toLowerCase();
}

// Calculate similarity between strings
function calculateSimilarity(str1: string, str2: string): number {
  const norm1 = normalizeArabic(str1);
  const norm2 = normalizeArabic(str2);
  
  if (norm1 === norm2) return 1.0;
  if (norm1.includes(norm2) || norm2.includes(norm1)) return 0.9;
  
  // Simple character-based similarity
  const maxLen = Math.max(norm1.length, norm2.length);
  if (maxLen === 0) return 1.0;
  
  let matches = 0;
  const minLen = Math.min(norm1.length, norm2.length);
  
  for (let i = 0; i < minLen; i++) {
    if (norm1[i] === norm2[i]) matches++;
  }
  
  return matches / maxLen;
}

// City name variations mapping
const cityNameVariations: Record<string, string[]> = {
  'ÿ®ÿ∫ÿØÿßÿØ': ['ÿ®ÿ∫ÿØÿßÿØ', 'Baghdad', 'baghdad'],
  'ÿßŸÑÿ®ÿµÿ±ÿ©': ['ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿ®ÿµÿ±ÿ©', 'Basra', 'basra'],
  'ŸÉÿ±ÿ®ŸÑÿßÿ°': ['ŸÉÿ±ÿ®ŸÑÿßÿ°', 'ŸÉÿ±ÿ®ŸÑÿß', 'Karbala', 'karbala'],
  'ÿßŸÑŸÜÿ¨ŸÅ': ['ÿßŸÑŸÜÿ¨ŸÅ', 'ŸÜÿ¨ŸÅ', 'Najaf', 'najaf'],
  'ÿ£ÿ±ÿ®ŸäŸÑ': ['ÿ£ÿ±ÿ®ŸäŸÑ', 'ÿßÿ±ÿ®ŸäŸÑ', 'Erbil', 'erbil'],
  'ÿßŸÑÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©': ['ÿßŸÑÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©', 'ÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©', 'Sulaymaniyah', 'sulaymaniyah'],
  'ÿßŸÑŸÖŸàÿµŸÑ': ['ÿßŸÑŸÖŸàÿµŸÑ', 'ŸÖŸàÿµŸÑ', 'Mosul', 'mosul'],
  'ÿØŸäÿßŸÑŸâ': ['ÿØŸäÿßŸÑŸâ', 'ÿØŸäÿßŸÑÿß', 'Diyala', 'diyala'],
  'ÿßŸÑÿ£ŸÜÿ®ÿßÿ±': ['ÿßŸÑÿ£ŸÜÿ®ÿßÿ±', 'ÿßŸÜÿ®ÿßÿ±', 'ÿßŸÑÿßŸÜÿ®ÿßÿ±', 'Anbar', 'anbar'],
  'ÿµŸÑÿßÿ≠ ÿßŸÑÿØŸäŸÜ': ['ÿµŸÑÿßÿ≠ ÿßŸÑÿØŸäŸÜ', 'ÿµŸÑÿßÿ≠', 'Salah al-Din', 'salah'],
  'ŸÉÿ±ŸÉŸàŸÉ': ['ŸÉÿ±ŸÉŸàŸÉ', 'Kirkuk', 'kirkuk'],
  'ŸÜŸäŸÜŸàŸâ': ['ŸÜŸäŸÜŸàŸâ', 'ŸÜŸäŸÜŸàÿß', 'Nineveh', 'nineveh'],
  'ÿ®ÿßÿ®ŸÑ': ['ÿ®ÿßÿ®ŸÑ', 'Babylon', 'babylon'],
  'Ÿàÿßÿ≥ÿ∑': ['Ÿàÿßÿ≥ÿ∑', 'Wasit', 'wasit'],
  'ÿ∞Ÿä ŸÇÿßÿ±': ['ÿ∞Ÿä ŸÇÿßÿ±', 'ÿ∞ŸäŸÇÿßÿ±', 'Dhi Qar', 'dhi qar'],
  'ÿßŸÑŸÖÿ´ŸÜŸâ': ['ÿßŸÑŸÖÿ´ŸÜŸâ', 'ŸÖÿ´ŸÜŸâ', 'Al-Muthanna', 'muthanna'],
  'ÿßŸÑŸÇÿßÿØÿ≥Ÿäÿ©': ['ÿßŸÑŸÇÿßÿØÿ≥Ÿäÿ©', 'ŸÇÿßÿØÿ≥Ÿäÿ©', 'Al-Qadisiyyah', 'qadisiyyah'],
  'ŸÖŸäÿ≥ÿßŸÜ': ['ŸÖŸäÿ≥ÿßŸÜ', 'Maysan', 'maysan']
};

// Find city by variation
function findCityByVariation(searchTerm: string): string | null {
  const normalized = normalizeArabic(searchTerm);
  
  for (const [standardName, variations] of Object.entries(cityNameVariations)) {
    for (const variation of variations) {
      if (normalizeArabic(variation) === normalized) {
        return standardName;
      }
    }
  }
  
  return null;
}

// Create flexible search terms for products
function createFlexibleSearchTerms(productName: string): string[] {
  const terms = [productName];
  const normalized = normalizeArabic(productName);
  
  if (normalized !== productName) {
    terms.push(normalized);
  }
  
  // Add partial terms
  const words = normalized.split(' ').filter(w => w.length > 2);
  terms.push(...words);
  
  return [...new Set(terms)];
}

// Search for product with variants and inventory
async function searchProductWithVariantsAndInventory(line: string, chatId: number, customerPhone?: string): Promise<{found: boolean, message?: string}> {
  try {
    console.log(`üîç Searching for product in line: "${line}"`);
    
    const details = parseProductDetails(line);
    console.log(`üìã Parsed details:`, details);
    
    if (!details.productName) {
      return { found: false, message: '‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨' };
    }
    
    const searchTerms = createFlexibleSearchTerms(details.productName);
    console.log(`üîç Search terms:`, searchTerms);
    
    let product = null;
    let variant = null;
    
    // Search for product
    for (const term of searchTerms) {
      const { data: products, error } = await supabase
        .from('products')
        .select(`
          id, name, price, cost_price,
          product_variants!inner(
            id, color_id, size_id, price, cost_price, stock_quantity,
            colors(name),
            sizes(name)
          )
        `)
        .ilike('name', `%${term}%`)
        .limit(10);
      
      if (!error && products && products.length > 0) {
        console.log(`‚úÖ Found ${products.length} products for term: ${term}`);
        
        // Find best matching product and variant
        for (const prod of products) {
          const similarity = calculateSimilarity(prod.name, details.productName);
          
          if (similarity >= 0.6) {
            product = prod;
            
            // Try to find matching variant
            if (prod.product_variants && prod.product_variants.length > 0) {
              let bestVariant = null;
              let bestScore = 0;
              
              for (const v of prod.product_variants) {
                let score = 0;
                
                // Check color match
                if (details.color && v.colors?.name) {
                  const colorSimilarity = calculateSimilarity(v.colors.name, details.color);
                  if (colorSimilarity >= 0.7) score += 0.5;
                }
                
                // Check size match
                if (details.size && v.sizes?.name) {
                  const sizeSimilarity = calculateSimilarity(v.sizes.name, details.size);
                  if (sizeSimilarity >= 0.7) score += 0.5;
                }
                
                if (score > bestScore) {
                  bestScore = score;
                  bestVariant = v;
                }
              }
              
              variant = bestVariant || prod.product_variants[0];
            }
            
            break;
          }
        }
        
        if (product) break;
      }
    }
    
    if (!product) {
      const phone = customerPhone || extractPhoneFromContext(chatId);
      return { 
        found: false, 
        message: generateStockAlert(null, details, phone)
      };
    }
    
    // Check inventory
    const { data: inventory, error: invError } = await supabase
      .from('inventory')
      .select('quantity, reserved_quantity')
      .eq(variant ? 'variant_id' : 'product_id', variant?.id || product.id)
      .single();
    
    const availableStock = inventory ? inventory.quantity - (inventory.reserved_quantity || 0) : 0;
    
    if (availableStock <= 0) {
      const phone = customerPhone || extractPhoneFromContext(chatId);
      return { 
        found: false, 
        message: generateStockAlert(product, details, phone, variant)
      };
    }
    
    console.log(`‚úÖ Product found: ${product.name}, Stock: ${availableStock}`);
    return { found: true };
    
  } catch (error) {
    console.error('‚ùå Error searching for product:', error);
    return { found: false, message: '‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖŸÜÿ™ÿ¨' };
  }
}

// Parse product details from text
function parseProductDetails(text: string): {productName: string, color?: string, size?: string} {
  const normalized = normalizeArabic(text);
  const words = normalized.split(' ').filter(w => w.trim().length > 0);
  
  // Common colors in Arabic
  const colors = ['ÿ£ÿ≠ŸÖÿ±', 'ÿ£ÿ≤ÿ±ŸÇ', 'ÿ£ÿÆÿ∂ÿ±', 'ÿ£ÿµŸÅÿ±', 'ÿ£ÿ≥ŸàÿØ', 'ÿ£ÿ®Ÿäÿ∂', 'Ÿàÿ±ÿØŸä', 'ÿ®ŸÜŸÅÿ≥ÿ¨Ÿä', 'ÿ®ÿ±ÿ™ŸÇÿßŸÑŸä', 'ÿ®ŸÜŸä', 'ÿ±ŸÖÿßÿØŸä', 'ÿ∞Ÿáÿ®Ÿä', 'ŸÅÿ∂Ÿä'];
  
  // Common sizes
  const sizes = ['ÿµÿ∫Ÿäÿ±', 'ŸÖÿ™Ÿàÿ≥ÿ∑', 'ŸÉÿ®Ÿäÿ±', 'ÿßŸÉÿ≥ ŸÑÿßÿ±ÿ¨', 'ŸÑÿßÿ±ÿ¨', 'ŸÖŸäÿØŸäŸàŸÖ', 'ÿ≥ŸÖŸàŸÑ', 'xl', 'l', 'm', 's', 'xxl'];
  
  let foundColor = '';
  let foundSize = '';
  let productWords: string[] = [];
  
  for (const word of words) {
    let isColorOrSize = false;
    
    // Check for color
    for (const color of colors) {
      if (calculateSimilarity(word, color) >= 0.8) {
        foundColor = color;
        isColorOrSize = true;
        break;
      }
    }
    
    // Check for size
    if (!isColorOrSize) {
      for (const size of sizes) {
        if (calculateSimilarity(word, size) >= 0.8) {
          foundSize = size;
          isColorOrSize = true;
          break;
        }
      }
    }
    
    if (!isColorOrSize) {
      productWords.push(word);
    }
  }
  
  return {
    productName: productWords.join(' '),
    color: foundColor || undefined,
    size: foundSize || undefined
  };
}

// Extract phone from context
function extractPhoneFromContext(chatId: number): string {
  // Simple fallback for now
  return `07${Math.floor(Math.random() * 100000000).toString().padStart(8, '0')}`;
}

// Generate stock alert
function generateStockAlert(product: any, details: any, phone: string, variant?: any): string {
  const productInfo = product ? 
    `ÿßŸÑŸÖŸÜÿ™ÿ¨: ${product.name}${variant?.colors?.name ? ` - ${variant.colors.name}` : ''}${variant?.sizes?.name ? ` - ${variant.sizes.name}` : ''}` :
    `ÿßŸÑŸÖŸÜÿ™ÿ¨ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®: ${details.productName}${details.color ? ` - ${details.color}` : ''}${details.size ? ` - ${details.size}` : ''}`;
  
  return `üö® ÿ™ŸÜÿ®ŸäŸá ŸÜŸÅÿßÿØ ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ

${productInfo}

üì± ÿ±ŸÇŸÖ ÿßŸÑÿπŸÖŸäŸÑ: ${phone}
‚è∞ ŸàŸÇÿ™ ÿßŸÑÿ∑ŸÑÿ®: ${new Date().toLocaleString('ar-EG')}

‚ùå Ÿáÿ∞ÿß ÿßŸÑŸÖŸÜÿ™ÿ¨ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ± ÿ≠ÿßŸÑŸäÿßŸã ŸÅŸä ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ

üîÑ Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ÿØÿßÿ¶ŸÑ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ© ÿ£Ÿà ÿßŸÜÿ™ÿ∏ÿßÿ± ŸàÿµŸàŸÑ ÿØŸÅÿπÿ© ÿ¨ÿØŸäÿØÿ©`;
}

// Smart city finder
async function findCityByNameSmart(cityName: string) {
  try {
    // Try RPC function first
    const { data, error } = await supabase.rpc('find_city_in_cache', {
      p_city_text: cityName
    });
    
    if (!error && data && data.length > 0) {
      return data[0];
    }
    
    // Fallback to local cache
    const cities = await getCitiesFromCache();
    let bestMatch = null;
    let bestScore = 0;
    
    for (const city of cities) {
      const score = calculateSimilarity(city.name, cityName);
      if (score > bestScore && score >= 0.7) {
        bestScore = score;
        bestMatch = city;
      }
    }
    
    return bestMatch;
  } catch (error) {
    console.error('Error in smart city search:', error);
    return null;
  }
}

// Parse address with smart matching
async function parseAddressWithSmartMatching(addressText: string) {
  const words = addressText.split(/\s+/).filter(w => w.trim().length > 0);
  let cityMatch = null;
  let regionMatch = null;
  let usedIndices = new Set();
  
  // Try to find city
  for (let i = 0; i < words.length; i++) {
    if (usedIndices.has(i)) continue;
    
    // Try single word
    let city = await findCityByNameSmart(words[i]);
    if (city) {
      cityMatch = city;
      usedIndices.add(i);
      break;
    }
    
    // Try two words
    if (i < words.length - 1) {
      city = await findCityByNameSmart(`${words[i]} ${words[i + 1]}`);
      if (city) {
        cityMatch = city;
        usedIndices.add(i);
        usedIndices.add(i + 1);
        break;
      }
    }
  }
  
  // Try to find region if city found
  if (cityMatch) {
    const regions = await getRegionsByCity(cityMatch.alwaseet_id);
    const remainingWords = words.filter((_, index) => !usedIndices.has(index));
    
    for (const regionCandidate of remainingWords) {
      for (const region of regions) {
        if (calculateSimilarity(region.name, regionCandidate) >= 0.7) {
          regionMatch = region;
          usedIndices.add(words.indexOf(regionCandidate));
          break;
        }
      }
      if (regionMatch) break;
    }
  }
  
  const remainingText = words
    .filter((_, index) => !usedIndices.has(index))
    .join(' ')
    .trim();
  
  return {
    city: cityMatch,
    region: regionMatch,
    address: remainingText,
    originalText: addressText
  };
}

// Get employee by Telegram chat ID
async function getEmployeeByTelegramId(chatId: number) {
  try {
    console.log(`üîç Looking for employee with chat ID: ${chatId}`);
    
    // Try using new RPC function
    const { data: rpcData, error: rpcError } = await supabase.rpc('get_employee_by_telegram_chat_id', {
      p_chat_id: chatId
    });
    
    if (!rpcError && rpcData?.success) {
      console.log(`üìã Employee RPC response:`, JSON.stringify(rpcData, null, 2));
      return rpcData.employee;
    }
    
    // Fallback to direct query if RPC fails
    const { data, error } = await supabase
      .from('employee_telegram_codes')
      .select(`
        user_id,
        telegram_code,
        telegram_chat_id,
        is_active,
        linked_at
      `)
      .eq('telegram_chat_id', chatId)
      .eq('is_active', true)
      .single();

    if (error) {
      console.error('‚ùå Error fetching employee:', error);
      return null;
    }

    if (data) {
      console.log(`üë§ Employee found via direct query:`, data);
      return {
        user_id: data.user_id,
        employee_code: data.telegram_code,
        telegram_chat_id: data.telegram_chat_id,
        is_active: data.is_active,
        full_name: 'ŸÖŸàÿ∏ŸÅ' // Default name for direct query
      };
    }

    return null;
  } catch (error) {
    console.error('‚ùå Exception in getEmployeeByTelegramId:', error);
    return null;
  }
}

// Link employee code to telegram chat ID
async function linkEmployeeCode(employeeCode: string, chatId: number) {
  try {
    console.log(`üîó Attempting to link employee code ${employeeCode} to chat ID ${chatId}`);
    
    const { data, error } = await supabase.rpc('link_employee_telegram_code', {
      p_employee_code: employeeCode,
      p_chat_id: chatId
    });

    if (error) {
      console.error('‚ùå Error linking employee code:', error);
      return { success: false, message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ±ÿ®ÿ∑ ÿßŸÑŸÉŸàÿØ' };
    }

    console.log(`‚úÖ Link employee response:`, JSON.stringify(data, null, 2));
    return data;
  } catch (error) {
    console.error('‚ùå Exception linking employee code:', error);
    return { success: false, message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ±ÿ®ÿ∑ ÿßŸÑŸÉŸàÿØ' };
  }
}

// Process order with AlWaseet
async function processOrderWithAlWaseet(text: string, chatId: number, employee: any) {
  try {
    console.log('üìã Processing order text...');
    
    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    if (lines.length < 3) {
      await sendTelegramMessage(chatId, `‚ùå ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ∑ŸÑÿ® ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠

üìã ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿµÿ≠Ÿäÿ≠:
ÿßŸÑŸÖÿØŸäŸÜÿ©
ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ  
ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ + ÿßŸÑŸÑŸàŸÜ + ÿßŸÑŸÖŸÇÿßÿ≥

ŸÖÿ´ÿßŸÑ:
ÿ®ÿ∫ÿØÿßÿØ
07700000000
ŸÇŸÖŸäÿµ ÿ£ÿ≤ÿ±ŸÇ ŸÑÿßÿ±ÿ¨`);
      return false;
    }
    
    // Parse basic info
    const cityText = lines[0];
    const phoneText = lines[1];
    const productLines = lines.slice(2);
    
    // Validate phone
    const phoneRegex = /^(07\d{9}|01\d{9}|\+9647\d{8})$/;
    if (!phoneRegex.test(phoneText.replace(/\s/g, ''))) {
      await sendTelegramMessage(chatId, `‚ùå ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠: ${phoneText}

üì± ÿßŸÑÿ£ÿ±ŸÇÿßŸÖ ÿßŸÑŸÖŸÇÿ®ŸàŸÑÿ©:
‚Ä¢ 07xxxxxxxxx
‚Ä¢ 01xxxxxxxxx  
‚Ä¢ +9647xxxxxxxx`);
      return false;
    }
    
    // Find city
    const city = await findCityByNameSmart(cityText);
    if (!city) {
      await sendTelegramMessage(chatId, `‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿØŸäŸÜÿ©: ${cityText}

üèôÔ∏è ÿßŸÑŸÖÿØŸÜ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©: ÿ®ÿ∫ÿØÿßÿØÿå ÿßŸÑÿ®ÿµÿ±ÿ©ÿå ŸÉÿ±ÿ®ŸÑÿßÿ°ÿå ÿßŸÑŸÜÿ¨ŸÅÿå ÿ£ÿ±ÿ®ŸäŸÑÿå ÿßŸÑŸÖŸàÿµŸÑ...`);
      return false;
    }
    
    // Check products
    const productResults = [];
    for (const productLine of productLines) {
      const result = await searchProductWithVariantsAndInventory(productLine, chatId, phoneText);
      if (!result.found) {
        await sendTelegramMessage(chatId, result.message || '‚ùå ŸÖŸÜÿ™ÿ¨ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±');
        return false;
      }
      productResults.push(productLine);
    }
    
    // All products available - simulate order creation
    const orderSummary = `‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ÿ®ŸÜÿ¨ÿßÿ≠!

üë§ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÖŸäŸÑ:
üèôÔ∏è ÿßŸÑŸÖÿØŸäŸÜÿ©: ${city.name}
üì± ÿßŸÑŸáÿßÿ™ŸÅ: ${phoneText}

üì¶ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™:
${productResults.map((p, i) => `${i + 1}. ${p}`).join('\n')}

üë®‚Äçüíº ÿßŸÑŸÖŸàÿ∏ŸÅ: ${employee.full_name} (${employee.employee_code})
‚è∞ ÿßŸÑŸàŸÇÿ™: ${new Date().toLocaleString('ar-EG')}

üîÑ ÿ¨ÿßÿ±Ÿä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ∑ŸÑÿ® ŸÑŸÑŸÜÿ∏ÿßŸÖ...`;

    await sendTelegramMessage(chatId, orderSummary);
    
    // Here you would typically save the order to the database
    console.log('‚úÖ Order processed successfully');
    return true;
    
  } catch (error) {
    console.error('‚ùå Error processing order:', error);
    await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
    return false;
  }
}

// Send welcome message
async function sendWelcomeMessage(chatId: number, employee: any) {
  const welcomeText = `ü§ñ ŸÖÿ±ÿ≠ÿ®ÿßŸã ${employee.full_name}!

ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÅŸä ÿ®Ÿàÿ™ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑŸÖÿ™ÿ∑Ÿàÿ± üöÄ

üìã ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ∑ŸÑÿ®ÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ™ÿßŸÑŸä:

ÿßŸÑŸÖÿØŸäŸÜÿ©
ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ
ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ + ÿßŸÑŸÑŸàŸÜ + ÿßŸÑŸÖŸÇÿßÿ≥

ŸÖÿ´ÿßŸÑ:
ÿ®ÿ∫ÿØÿßÿØ
07700000000
ŸÇŸÖŸäÿµ ÿ£ÿ≤ÿ±ŸÇ ŸÑÿßÿ±ÿ¨

‚ú® ÿßŸÑŸÖÿ≤ÿßŸäÿß ÿßŸÑÿ∞ŸÉŸäÿ©:
üîç ÿ™ÿπÿ±ŸÅ ÿ™ŸÑŸÇÿßÿ¶Ÿä ÿπŸÑŸâ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸàÿßŸÑÿ£ŸÑŸàÿßŸÜ ŸàÿßŸÑÿ£ÿ≠ÿ¨ÿßŸÖ
üìä ŸÅÿ≠ÿµ ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ ÿßŸÑŸÅŸàÿ±Ÿä
üö® ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ŸÜŸÅÿßÿØ ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ
üéØ ÿßŸÇÿ™ÿ±ÿßÿ≠ ÿßŸÑÿ®ÿØÿßÿ¶ŸÑ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©

üë®‚Äçüíº ÿßŸÑŸÖŸàÿ∏ŸÅ: ${employee.employee_code}`;

  await sendTelegramMessage(chatId, welcomeText);
}

// Main handler
serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const update: TelegramUpdate = await req.json();
    console.log('üì® Received Telegram update:', JSON.stringify(update, null, 2));

    if (!update.message) {
      return new Response('OK', { headers: corsHeaders });
    }

    const message = update.message;
    const chatId = message.chat.id;
    const text = message.text || '';

    console.log(`üí¨ Processing message from chat ${chatId}: "${text}"`);

    // Check if this is an employee code for linking
    if (text && /^[A-Z]{3}\d{3,4}$/.test(text.trim())) {
      console.log(`üîó Detected employee code pattern: ${text.trim()}`);
      
      // Try to link this code
      const linkResult = await linkEmployeeCode(text.trim(), chatId);
      
      if (linkResult.success) {
        await sendTelegramMessage(chatId, `‚úÖ ÿ™ŸÖ ÿ±ÿ®ÿ∑ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠!
        
üë§ ŸÖÿ±ÿ≠ÿ®ÿßŸã ${linkResult.employee?.full_name || 'ÿπÿ≤Ÿäÿ≤Ÿä ÿßŸÑŸÖŸàÿ∏ŸÅ'}
üÜî ŸÉŸàÿØ ÿßŸÑŸÖŸàÿ∏ŸÅ: ${linkResult.employee?.employee_code}

üìã ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿ®ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ™ÿßŸÑŸä:
ÿßŸÑŸÖÿØŸäŸÜÿ©
ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ  
ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ + ÿßŸÑŸÑŸàŸÜ + ÿßŸÑŸÖŸÇÿßÿ≥

ŸÖÿ´ÿßŸÑ:
ÿ®ÿ∫ÿØÿßÿØ
07700000000
ŸÇŸÖŸäÿµ ÿ£ÿ≤ÿ±ŸÇ ŸÑÿßÿ±ÿ¨`);
        
        return new Response('OK', { headers: corsHeaders });
      } else {
        await sendTelegramMessage(chatId, `‚ùå ${linkResult.message || 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ±ÿ®ÿ∑ ÿßŸÑŸÉŸàÿØ'}
        
üîó ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿ≥ÿßÿπÿØÿ©:
1. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÉŸàÿØ
2. ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿØŸäÿ±
3. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÉŸàÿØ ÿ∫Ÿäÿ± ŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿ≥ÿ®ŸÇÿßŸã`);
        
        return new Response('OK', { headers: corsHeaders });
      }
    }

    // Get employee information
    const employee = await getEmployeeByTelegramId(chatId);
    
    if (!employee) {
      console.error(`No employee found for chat ID: ${chatId}`);
      await sendTelegramMessage(chatId, `‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ÿ≥ÿßÿ® ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿ±ŸÇŸÖ.
      
üîó ŸÑÿ±ÿ®ÿ∑ ÿ≠ÿ≥ÿßÿ®ŸÉ:
1. ÿßÿ≠ÿµŸÑ ÿπŸÑŸâ ŸÉŸàÿØ ÿßŸÑŸÖŸàÿ∏ŸÅ ŸÖŸÜ ÿßŸÑŸÖÿØŸäÿ±
2. ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÉŸàÿØ ŸáŸÜÿß ŸÖÿ®ÿßÿ¥ÿ±ÿ©

üìÑ ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÉŸàÿØ: ABC123 ÿ£Ÿà ABC1234
ŸÖÿ´ÿßŸÑ: RYU559`);
      return new Response('OK', { headers: corsHeaders });
    }

    console.log(`üë§ Employee found: ${employee.full_name} (${employee.employee_code})`);

    // Handle start command
    if (text === '/start' || text === '/help') {
      await sendWelcomeMessage(chatId, employee);
      return new Response('OK', { headers: corsHeaders });
    }

    // Process order text
    try {
      console.log('üì¶ Processing order text...');
      await processOrderWithAlWaseet(text, chatId, employee);
      console.log('‚úÖ Order processing completed successfully');
    } catch (orderError) {
      console.error('‚ùå Order processing failed:', orderError);
      await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.');
    }

    return new Response('OK', { headers: corsHeaders });

  } catch (error) {
    console.error('‚ùå Error processing request:', error);
    return new Response('Error', { 
      status: 500, 
      headers: corsHeaders 
    });
  }
});