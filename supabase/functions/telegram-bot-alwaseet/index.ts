import { serve } from "https://deno.land/std@0.208.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// Initialize Supabase client
const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
const supabase = createClient(supabaseUrl, supabaseServiceKey)

// Telegram Bot Token
const TELEGRAM_BOT_TOKEN = Deno.env.get('TELEGRAM_BOT_TOKEN')!

interface TelegramMessage {
  message_id: number
  from: {
    id: number
    first_name: string
    username?: string
  }
  chat: {
    id: number
    type: string
  }
  text: string
  date: number
}

interface TelegramUpdate {
  update_id: number
  message?: TelegramMessage
}

// Send message to Telegram
async function sendTelegramMessage(chatId: number, text: string) {
  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      text: text,
      parse_mode: 'HTML'
    })
  })
  return response.json()
}

// Get cities from cache database (fast and updated)
async function getCitiesFromCache(): Promise<any[]> {
  try {
    const { data: cities, error } = await supabase
      .from('cities_cache')
      .select('id, name, original_id')
      .eq('is_active', true)
      .order('name')
    
    if (error) {
      console.error('Error fetching cities from cache:', error)
      return []
    }
    
    return cities || []
  } catch (error) {
    console.error('Error in getCitiesFromCache:', error)
    return []
  }
}

// Get regions by city from cache database (fast and updated)
async function getRegionsByCity(cityId: number): Promise<any[]> {
  try {
    const { data: regions, error } = await supabase
      .from('regions_cache')
      .select('id, name, original_id')
      .eq('city_id', cityId)
      .eq('is_active', true)
      .order('name')
    
    if (error) {
      console.error('Error fetching regions from cache:', error)
      return []
    }
    
    return regions || []
  } catch (error) {
    console.error('Error in getRegionsByCity:', error)
    return []
  }
}

// Enhanced Arabic text normalization for superior matching capabilities
function normalizeArabic(text: string): string {
  if (!text) return ''
  
  return text.toString().trim()
    // Remove common prefixes and suffixes
    .replace(/^(ÿßŸÑ|ŸÖÿ≠ÿßŸÅÿ∏ÿ©|ŸÖÿØŸäŸÜÿ©|ŸÇÿ∂ÿßÿ°|ŸÜÿßÿ≠Ÿäÿ©)\s+/g, '')
    .replace(/\s+(ŸÖÿ≠ÿßŸÅÿ∏ÿ©|ŸÇÿ∂ÿßÿ°|ŸÜÿßÿ≠Ÿäÿ©)$/g, '')
    // Enhanced Arabic letter normalization
    .replace(/[ÿ£ÿ•ÿ¢]/g, 'ÿß')
    .replace(/[ÿ©Ÿá]/g, 'Ÿá')
    .replace(/[ŸäŸâ]/g, 'Ÿä')
    .replace(/[ÿ§]/g, 'Ÿà')
    .replace(/[ÿ¶]/g, 'Ÿä')
    .replace(/[ÿ°]/g, '')
    // Handle diacritics completely
    .replace(/[\u064B-\u065F\u0670\u0640]/g, '')
    // Remove extra spaces and punctuation
    .replace(/[.,ÿåÿõ:]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase()
}

// Calculate string similarity for fuzzy matching
function calculateSimilarity(str1: string, str2: string): number {
  const longer = str1.length > str2.length ? str1 : str2
  const shorter = str1.length > str2.length ? str2 : str1
  
  if (longer.length === 0) return 1.0
  
  // Exact match
  if (longer === shorter) return 1.0
  
  // Contains check
  if (longer.includes(shorter) || shorter.includes(longer)) {
    return 0.8 + (shorter.length / longer.length) * 0.2
  }
  
  // Levenshtein distance
  const matrix = Array(longer.length + 1).fill(null).map(() => Array(shorter.length + 1).fill(null))
  
  for (let i = 0; i <= longer.length; i++) matrix[i][0] = i
  for (let j = 0; j <= shorter.length; j++) matrix[0][j] = j
  
  for (let i = 1; i <= longer.length; i++) {
    for (let j = 1; j <= shorter.length; j++) {
      const cost = longer[i - 1] === shorter[j - 1] ? 0 : 1
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      )
    }
  }
  
  const distance = matrix[longer.length][shorter.length]
  return 1.0 - (distance / longer.length)
}

// Import the smart cache parser
import { parseAddressWithCache } from '../telegram-bot/address-cache-parser.ts'

// Comprehensive city name variations for all 18 Iraqi cities with smart matching
const cityNameVariations: { [key: string]: string[] } = {
  'ÿßŸÑÿØŸäŸàÿßŸÜŸäÿ©': ['ÿØŸäŸàÿßŸÜŸäÿ©', 'ÿßŸÑÿØŸäŸàÿßŸÜŸäÿ©', 'ÿØŸäŸàÿßŸÜŸäŸá', 'ÿßŸÑÿØŸäŸàÿßŸÜŸäŸá', 'ÿßŸÑŸÇÿßÿØÿ≥Ÿäÿ©', 'ÿßŸÑŸÇÿßÿØÿ≥ŸäŸá', 'ŸÇÿßÿØÿ≥Ÿäÿ©', 'qadisiyah'],
  'ÿ®ÿ∫ÿØÿßÿØ': ['ÿ®ÿ∫ÿØÿßÿØ', 'Baghdad', 'baghdad', 'ÿ®ÿ∫ÿØÿØ', 'ÿ®ŸÇÿØÿßÿØ'],
  'ÿßŸÑÿ®ÿµÿ±ÿ©': ['ÿßŸÑÿ®ÿµÿ±Ÿá', 'ÿ®ÿµÿ±ÿ©', 'ÿ®ÿµÿ±Ÿá', 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'basrah', 'basra'],
  'ÿßÿ±ÿ®ŸäŸÑ': ['ÿ£ÿ±ÿ®ŸäŸÑ', 'ÿßÿ±ÿ®ŸäŸÑ', 'ÿ£ÿ±ÿ®ŸäŸÑ', 'ÿßÿ±ÿ®ŸÑ', 'Erbil', 'erbil', 'ŸáŸàŸÑŸäÿ±'],
  'ÿØŸáŸàŸÉ': ['ÿØŸáŸàŸÉ', 'ÿØŸáŸÉ', 'Dohuk', 'dohuk', 'dahuk'],
  'ŸÉÿ±ÿ®ŸÑÿßÿ°': ['ŸÉÿ±ÿ®ŸÑÿßÿ°', 'ŸÉÿ±ÿ®ŸÑÿß', 'ŸÉÿ±ÿ®ŸÑŸá', 'Karbala', 'karbala'],
  'ÿßŸÑŸÜÿ¨ŸÅ': ['ÿßŸÑŸÜÿ¨ŸÅ', 'ŸÜÿ¨ŸÅ', 'ŸÜÿ¨ÿßŸÅ', 'Najaf', 'najaf'],
  'ŸÜŸäŸÜŸàŸâ': ['ŸÜŸäŸÜŸàŸâ', 'ŸÜŸäŸÜŸàÿß', 'ÿßŸÑŸÖŸàÿµŸÑ', 'ŸÖŸàÿµŸÑ', 'ŸÜŸäŸÜŸàŸá', 'Nineveh', 'nineveh', 'mosul'],
  'ÿµŸÑÿßÿ≠ ÿßŸÑÿØŸäŸÜ': ['ÿµŸÑÿßÿ≠ ÿßŸÑÿØŸäŸÜ', 'ÿµŸÑÿßÿ≠ÿØŸäŸÜ', 'ÿ™ŸÉÿ±Ÿäÿ™', 'ÿ™ŸÉÿ±ÿ™', 'salahuddin', 'tikrit'],
  'ÿßŸÑÿ£ŸÜÿ®ÿßÿ±': ['ÿßŸÑÿ£ŸÜÿ®ÿßÿ±', 'ÿßŸÑÿßŸÜÿ®ÿßÿ±', 'ÿßŸÜÿ®ÿßÿ±', 'ÿ£ŸÜÿ®ÿßÿ±', 'ÿßŸÑÿ±ŸÖÿßÿØŸä', 'ÿ±ŸÖÿßÿØŸä', 'anbar', 'ramadi'],
  'ÿ®ÿßÿ®ŸÑ': ['ÿ®ÿßÿ®ŸÑ', 'ÿßŸÑÿ≠ŸÑÿ©', 'ÿ≠ŸÑÿ©', 'ÿ≠ŸÑŸá', 'babylon', 'hillah', 'hilla'],
  'Ÿàÿßÿ≥ÿ∑': ['Ÿàÿßÿ≥ÿ∑', 'ÿßŸÑŸÉŸàÿ™', 'ŸÉŸàÿ™', 'ŸÉÿ™', 'Wasit', 'wasit', 'kut'],
  'ÿ∞Ÿä ŸÇÿßÿ±': ['ÿ∞Ÿä ŸÇÿßÿ±', 'ÿ∞ŸäŸÇÿßÿ±', 'ÿßŸÑŸÜÿßÿµÿ±Ÿäÿ©', 'ŸÜÿßÿµÿ±Ÿäÿ©', 'ŸÜÿßÿµÿ±ŸäŸá', 'thi qar', 'nasiriyah'],
  'ÿßŸÑŸÖÿ´ŸÜŸâ': ['ÿßŸÑŸÖÿ´ŸÜŸâ', 'ŸÖÿ´ŸÜŸâ', 'ÿßŸÑÿ≥ŸÖÿßŸàÿ©', 'ÿ≥ŸÖÿßŸàÿ©', 'ÿ≥ŸÖÿßŸàŸá', 'muthanna', 'samawah'],
  'ŸÖŸäÿ≥ÿßŸÜ': ['ŸÖŸäÿ≥ÿßŸÜ', 'ÿßŸÑÿπŸÖÿßÿ±ÿ©', 'ÿπŸÖÿßÿ±ÿ©', 'ÿπŸÖÿßÿ±Ÿá', 'Maysan', 'maysan', 'amarah'],
  'ŸÉÿ±ŸÉŸàŸÉ': ['ŸÉÿ±ŸÉŸàŸÉ', 'ŸÉÿ±ŸÉŸÉ', 'Kirkuk', 'kirkuk'],
  'ÿßŸÑÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©': ['ÿßŸÑÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©', 'ÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©', 'ÿ≥ŸÑŸäŸÖÿßŸÜŸäŸá', 'Sulaymaniyah', 'sulaymaniyah'],
  'ÿ≠ŸÑÿ®ÿ¨ÿ©': ['ÿ≠ŸÑÿ®ÿ¨ÿ©', 'ÿ≠ŸÑÿ®ÿ¨Ÿá', 'halabja', 'halabcha']
}

// Enhanced flexible product search that handles both ÿ© and Ÿá with detailed logging
function createFlexibleSearchTerms(productName: string): string[] {
  const normalized = normalizeArabic(productName)
  const terms = [
    productName,
    normalized,
    productName.replace(/ÿ©/g, 'Ÿá'),
    productName.replace(/Ÿá/g, 'ÿ©'),
    normalized.replace(/ÿ©/g, 'Ÿá'),
    normalized.replace(/Ÿá/g, 'ÿ©')
  ]
  
  // Add partial matching for single words
  const words = productName.split(/\s+/);
  if (words.length === 1 && words[0].length >= 3) {
    terms.push(words[0]);
    terms.push(normalizeArabic(words[0]));
  }
  
  const uniqueTerms = [...new Set(terms)]
  console.log(`üîç Search terms for "${productName}":`, uniqueTerms)
  return uniqueTerms
}

// Smart city finder using cache system with fuzzy matching
async function findCityByNameSmart(cityName: string): Promise<{ city: any | null, suggestions: any[], confidence: number }> {
  try {
    // Use the smart cache system for primary search
    const { data: cityMatches, error } = await supabase.rpc('find_city_in_cache', {
      p_city_text: cityName
    })
    
    if (!error && cityMatches && cityMatches.length > 0) {
      const bestMatch = cityMatches[0]
      if (bestMatch.similarity_score >= 0.7) {
        console.log(`üèôÔ∏è Ÿàÿ¨ÿØÿ™ ŸÖÿØŸäŸÜÿ© ÿ∞ŸÉŸäÿ©: ${bestMatch.name} (${bestMatch.similarity_score})`)
        return { 
          city: { id: bestMatch.alwaseet_id, name: bestMatch.name, original_id: bestMatch.alwaseet_id }, 
          suggestions: [], 
          confidence: bestMatch.similarity_score 
        }
      }
    }
    
    // Fallback to local cache
    const cities = await getCitiesFromCache()
    const normalizedName = normalizeArabic(cityName)
    
    if (!cities.length) {
      return { city: null, suggestions: [], confidence: 0 }
    }
    
    let bestCity = null
    let bestScore = 0
    const allMatches = []
    
    // Direct and variation matching with scoring
    for (const city of cities) {
      const cityNormalized = normalizeArabic(city.name)
      let score = calculateSimilarity(normalizedName, cityNormalized)
      
      // Check variations
      for (const [standardName, variations] of Object.entries(cityNameVariations)) {
        if (variations.some(variant => {
          const normalizedVariant = normalizeArabic(variant)
          const variantScore = calculateSimilarity(normalizedName, normalizedVariant)
          if (variantScore > score) score = variantScore
          return variantScore >= 0.7
        })) {
          const standardNormalized = normalizeArabic(standardName)
          if (cityNormalized.includes(standardNormalized) || standardNormalized.includes(cityNormalized)) {
            score = Math.max(score, 0.9)
          }
        }
      }
      
      if (score >= 0.7) {
        allMatches.push({ city, score })
        if (score > bestScore) {
          bestScore = score
          bestCity = city
        }
      } else if (score >= 0.5) {
        // Lower confidence suggestions
        allMatches.push({ city, score })
      }
    }
    
    if (bestCity && bestScore >= 0.7) {
      console.log(`‚úÖ ÿπÿ´ÿ± ÿπŸÑŸâ ŸÖÿØŸäŸÜÿ©: ${cityName} ‚Üí ${bestCity.name} (${bestScore.toFixed(2)})`)
      return { city: bestCity, suggestions: [], confidence: bestScore }
    }
    
    // Return suggestions if no good match
    const suggestions = allMatches
      .sort((a, b) => b.score - a.score)
      .slice(0, 5)
      .map(m => m.city)
    
    return { city: null, suggestions, confidence: bestScore }
    
  } catch (error) {
    console.error('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑÿ∞ŸÉŸä ÿπŸÜ ÿßŸÑŸÖÿØŸäŸÜÿ©:', error)
    return { city: null, suggestions: [], confidence: 0 }
  }
}

// Comprehensive neighborhood to city mapping for smart default city detection
const neighborhoodToCityMap: { [key: string]: string } = {
  // ÿ®ÿ∫ÿØÿßÿØ - ÿ¥ÿßŸÖŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ≠Ÿäÿßÿ° ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
  'ÿßŸÑÿßÿπÿ∏ŸÖŸäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿßÿπÿ∏ŸÖŸäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÉÿ±ÿßÿØÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉÿ±ÿßÿØÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉÿ±ÿßÿØŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿØŸàÿ±ÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿØŸàÿ±ÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿØŸàÿ±Ÿá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÖŸÜÿµŸàÿ±': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÖŸÜÿµŸàÿ±': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÉÿßÿ∏ŸÖŸäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉÿßÿ∏ŸÖŸäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉÿßÿ∏ŸÖŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ¥ÿπŸÑÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¥ÿπŸÑÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¥ÿπŸÑŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ¨ŸáÿßÿØ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¨ŸáÿßÿØ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≠Ÿä ÿßŸÑÿ¨ŸáÿßÿØ': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ®Ÿäÿßÿπ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ®Ÿäÿßÿπ': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ∫ÿØŸäÿ±': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ∫ÿØŸäÿ±': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ≤ÿπŸÅÿ±ÿßŸÜŸäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≤ÿπŸÅÿ±ÿßŸÜŸäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≤ÿπŸÅÿ±ÿßŸÜŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÜŸáÿ±ŸàÿßŸÜ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÜŸáÿ±ŸàÿßŸÜ': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßÿ®Ÿà ÿ∫ÿ±Ÿäÿ®': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ£ÿ®Ÿà ÿ∫ÿ±Ÿäÿ®': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ™ÿßÿ¨Ÿä': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ™ÿßÿ¨Ÿä': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ≠ÿ±Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≠ÿ±Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≠ÿ±ŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ±ÿ≥ÿßŸÑÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ±ÿ≥ÿßŸÑŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ¥ÿπÿ®': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¥ÿπÿ®': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿµÿØÿ±': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿµÿØÿ±': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÖÿØŸäŸÜÿ© ÿßŸÑÿµÿØÿ±': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ´Ÿàÿ±ÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ´Ÿàÿ±ÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ´Ÿàÿ±Ÿá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÖÿ≥ÿ®ÿ≠': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÖÿ≥ÿ®ÿ≠': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÉŸÅÿßÿ≠': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉŸÅÿßÿ≠': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ¨ÿßŸÖÿπÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¨ÿßŸÖÿπÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¨ÿßŸÖÿπŸá': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≠Ÿä ÿßŸÑÿ¨ÿßŸÖÿπÿ©': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿπÿßŸÖÿ±Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿπÿßŸÖÿ±Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿπÿßŸÖÿ±ŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿØŸàŸÑÿπŸä': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿØŸàŸÑÿπŸä': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¨ÿ≤ÿßÿ¶ÿ±': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ®Ÿäÿ¨Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ®Ÿäÿ¨Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ®Ÿäÿ¨ŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÖÿ¥ÿ™ŸÑ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÖÿ¥ÿ™ŸÑ': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ¥ŸÑÿ¨Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¥ŸÑÿ¨Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¥ŸÑÿ¨ŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÉÿßÿ™ÿ®': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉÿßÿ™ÿ®': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ®ŸÑÿØŸäÿßÿ™': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ®ŸÑÿØŸäÿßÿ™': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ¨ÿßÿØÿ±Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¨ÿßÿØÿ±Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ¨ÿßÿØÿ±ŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ≤Ÿàÿ±ÿßÿ°': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≤Ÿàÿ±ÿßÿ°': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿßŸÜÿØŸÑÿ≥': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿßŸÜÿØŸÑÿ≥': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ£ŸÜÿØŸÑÿ≥': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿπÿØŸÑ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿπÿØŸÑ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≠Ÿä ÿßŸÑÿπÿØŸÑ': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿµÿßŸÑÿ≠Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿµÿßŸÑÿ≠Ÿäÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿµÿßŸÑÿ≠ŸäŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÉÿ±ŸäŸÖÿßÿ™': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉÿ±ŸäŸÖÿßÿ™': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ±ÿµÿßŸÅÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ±ÿµÿßŸÅÿ©': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ±ÿµÿßŸÅŸá': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑŸÉÿ±ÿÆ': 'ÿ®ÿ∫ÿØÿßÿØ', 'ŸÉÿ±ÿÆ': 'ÿ®ÿ∫ÿØÿßÿØ',
  'ÿßŸÑÿ£ÿ∑ÿ®ÿßÿ°': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿßÿ∑ÿ®ÿßÿ°': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ£ÿ∑ÿ®ÿßÿ°': 'ÿ®ÿ∫ÿØÿßÿØ', 'ÿ≠Ÿä ÿßŸÑÿ£ÿ∑ÿ®ÿßÿ°': 'ÿ®ÿ∫ÿØÿßÿØ',
  
  // ÿßŸÑÿ®ÿµÿ±ÿ©
  'ÿßŸÑÿπÿ¥ÿßÿ±': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿπÿ¥ÿßÿ±': 'ÿßŸÑÿ®ÿµÿ±ÿ©',
  'ÿßŸÑŸÖÿπŸÇŸÑ': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ŸÖÿπŸÇŸÑ': 'ÿßŸÑÿ®ÿµÿ±ÿ©',
  'ÿßŸÑÿ™ŸÜŸàŸÖÿ©': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿ™ŸÜŸàŸÖÿ©': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿ™ŸÜŸàŸÖŸá': 'ÿßŸÑÿ®ÿµÿ±ÿ©',
  'ÿßŸÑÿ£ÿ≥ŸÖÿßŸÉ': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿßÿ≥ŸÖÿßŸÉ': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿ£ÿ≥ŸÖÿßŸÉ': 'ÿßŸÑÿ®ÿµÿ±ÿ©',
  'ÿßŸÑŸÅŸäÿ≠ÿßÿ°': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ŸÅŸäÿ≠ÿßÿ°': 'ÿßŸÑÿ®ÿµÿ±ÿ©',
  'ŸÉÿ±ŸÖÿ© ÿπŸÑŸä': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ŸÉÿ±ŸÖŸá ÿπŸÑŸä': 'ÿßŸÑÿ®ÿµÿ±ÿ©',
  'ÿßŸÑÿ¨ŸÖŸáŸàÿ±Ÿäÿ©': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿ¨ŸÖŸáŸàÿ±Ÿäÿ©': 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿ¨ŸÖŸáŸàÿ±ŸäŸá': 'ÿßŸÑÿ®ÿµÿ±ÿ©',
  
  // ÿ£ÿ±ÿ®ŸäŸÑ
  'ÿπŸÜŸÉÿßŸàÿß': 'ÿßÿ±ÿ®ŸäŸÑ', 'ÿπŸÜŸÉÿßŸàŸá': 'ÿßÿ±ÿ®ŸäŸÑ',
  'ÿ¥Ÿàÿ±ÿ¥': 'ÿßÿ±ÿ®ŸäŸÑ',
  'ÿ®ÿßÿÆÿ™Ÿäÿßÿ±Ÿä': 'ÿßÿ±ÿ®ŸäŸÑ',
  'ŸÇŸÑÿßŸàÿ±Ÿä': 'ÿßÿ±ÿ®ŸäŸÑ',
  
  // ŸÉÿ±ÿ®ŸÑÿßÿ°
  'ÿßŸÑÿ≠ÿ±': 'ŸÉÿ±ÿ®ŸÑÿßÿ°', 'ÿ≠ÿ±': 'ŸÉÿ±ÿ®ŸÑÿßÿ°',
  'ÿßŸÑÿ¨ÿØŸäÿØÿ©': 'ŸÉÿ±ÿ®ŸÑÿßÿ°', 'ÿ¨ÿØŸäÿØÿ©': 'ŸÉÿ±ÿ®ŸÑÿßÿ°', 'ÿ¨ÿØŸäÿØŸá': 'ŸÉÿ±ÿ®ŸÑÿßÿ°',
  
  // ÿßŸÑŸÜÿ¨ŸÅ
  'ÿßŸÑŸÉŸàŸÅÿ©': 'ÿßŸÑŸÜÿ¨ŸÅ', 'ŸÉŸàŸÅÿ©': 'ÿßŸÑŸÜÿ¨ŸÅ', 'ŸÉŸàŸÅŸá': 'ÿßŸÑŸÜÿ¨ŸÅ',
  'ÿßŸÑÿ≠ŸäÿØÿ±Ÿäÿ©': 'ÿßŸÑŸÜÿ¨ŸÅ', 'ÿ≠ŸäÿØÿ±Ÿäÿ©': 'ÿßŸÑŸÜÿ¨ŸÅ', 'ÿ≠ŸäÿØÿ±ŸäŸá': 'ÿßŸÑŸÜÿ¨ŸÅ',
  
  // Catch-all for unrecognized neighborhoods ‚Üí default to Baghdad
  'ÿ∫ŸÖÿßÿ≥': 'ÿßŸÑÿØŸäŸàÿßŸÜŸäÿ©'
}

// Find regions by partial name with disambiguation
async function findRegionsByName(cityId: number, regionText: string): Promise<any[]> {
  if (!regionText || !cityId) return []
  
  const regions = await getRegionsByCity(cityId)
  const normalizedText = normalizeArabic(regionText)
  
  // Find all matching regions
  const matchingRegions = regions.filter(region => {
    const normalizedRegion = normalizeArabic(region.name)
    return normalizedRegion.includes(normalizedText) || 
           normalizedText.includes(normalizedRegion)
  })
  
  return matchingRegions
}

// Enhanced smart address parsing using cache system
async function parseAddressLineSmart(addressText: string): Promise<{
  customerName?: string,
  city: any | null,
  region: any | null,
  remainingText: string,
  isDefaultCity: boolean,
  errors: string[],
  suggestions: { cities?: any[], regions?: any[] }
}> {
  console.log(`üß† ÿ™ÿ≠ŸÑŸäŸÑ ÿ∞ŸÉŸä ŸÑŸÑÿπŸÜŸàÿßŸÜ: "${addressText}"`)
  
  if (!addressText || addressText.trim().length === 0) {
    return { 
      city: null, region: null, remainingText: '', isDefaultCity: false, 
      errors: ['ŸÑÿß ŸäŸàÿ¨ÿØ ŸÜÿµ ÿπŸÜŸàÿßŸÜ ÿµÿßŸÑÿ≠'], suggestions: {} 
    }
  }
  
  const errors: string[] = []
  let isDefaultCity = false
  let city = null
  let region = null
  let customerName = ''
  let suggestions: { cities?: any[], regions?: any[] } = {}
  
  try {
    // Use the smart cache system first
    const cacheResult = await parseAddressWithCache(addressText)
    console.log('üéØ ŸÜÿ™Ÿäÿ¨ÿ© Cache ÿßŸÑÿ∞ŸÉŸäÿ©:', cacheResult)
    
    customerName = cacheResult.customer_name || ''
    
    if (cacheResult.city_id && cacheResult.city_name) {
      city = { 
        id: cacheResult.city_id, 
        name: cacheResult.city_name, 
        original_id: cacheResult.city_id 
      }
      console.log(`‚úÖ ŸÖÿØŸäŸÜÿ© ŸÖŸÜ Cache: ${city.name}`)
    }
    
    if (cacheResult.region_id && cacheResult.region_name) {
      region = {
        id: cacheResult.region_id,
        name: cacheResult.region_name,
        original_id: cacheResult.region_id
      }
      console.log(`‚úÖ ŸÖŸÜÿ∑ŸÇÿ© ŸÖŸÜ Cache: ${region.name}`)
    }
    
    // If no city found via cache, try smart fallback
    if (!city) {
      const addressParts = addressText.split(/[\sÿå,]+/).filter(Boolean)
      console.log('üîç ÿ£ÿ¨ÿ≤ÿßÿ° ÿßŸÑÿπŸÜŸàÿßŸÜ:', addressParts)
      
      // Check for neighborhoods to determine default city
      for (const part of addressParts) {
        const normalizedPart = normalizeArabic(part)
        
        for (const [neighborhood, cityName] of Object.entries(neighborhoodToCityMap)) {
          const normalizedNeighborhood = normalizeArabic(neighborhood)
          
          if (normalizedPart.includes(normalizedNeighborhood) || 
              normalizedNeighborhood.includes(normalizedPart) ||
              calculateSimilarity(normalizedPart, normalizedNeighborhood) >= 0.8) {
            
            console.log(`üèòÔ∏è ÿßŸÉÿ™ÿ¥ŸÅ ÿ≠Ÿä: "${neighborhood}" ‚Üí ŸÖÿØŸäŸÜÿ©: ${cityName}`)
            
            const defaultCityResult = await findCityByNameSmart(cityName)
            if (defaultCityResult.city) {
              city = defaultCityResult.city
              isDefaultCity = true
              console.log(`‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿØŸäŸÜÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©: ${city.name}`)
              break
            }
          }
        }
        if (city) break
      }
      
      // If still no city, try to find from first part
      if (!city && addressParts.length > 0) {
        const firstPartResult = await findCityByNameSmart(addressParts[0])
        
        if (firstPartResult.city && firstPartResult.confidence >= 0.7) {
          city = firstPartResult.city
          console.log(`‚úÖ ŸÖÿØŸäŸÜÿ© ŸÖŸÜ ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ£ŸàŸÑ: ${city.name}`)
        } else if (firstPartResult.suggestions.length > 0) {
          suggestions.cities = firstPartResult.suggestions
          errors.push(`ÿßŸÑŸÖÿØŸäŸÜÿ© "${addressParts[0]}" ÿ∫Ÿäÿ± Ÿàÿßÿ∂ÿ≠ÿ©. ŸáŸÑ ÿ™ŸÇÿµÿØ ÿ•ÿ≠ÿØŸâ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿØŸÜÿü`)
        }
      }
      
      // Ultimate fallback to Baghdad if region detected but no city
      if (!city && addressParts.length > 0) {
        const baghdadResult = await findCityByNameSmart('ÿ®ÿ∫ÿØÿßÿØ')
        if (baghdadResult.city) {
          city = baghdadResult.city
          isDefaultCity = true
          console.log(`üèôÔ∏è ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ®ÿ∫ÿØÿßÿØ ŸÉÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÜŸáÿßÿ¶Ÿä`)
        }
      }
    }
    
    // If no region found via cache, try manual search
    if (city && !region) {
      const addressParts = addressText.split(/[\sÿå,]+/).filter(Boolean)
      const startIndex = isDefaultCity ? 0 : 1 // Skip city name if not default
      
      for (let i = startIndex; i < addressParts.length; i++) {
        for (let j = i; j < Math.min(i + 3, addressParts.length); j++) {
          const regionCandidate = addressParts.slice(i, j + 1).join(' ')
          
          try {
            const { data: regionMatches, error } = await supabase.rpc('find_region_in_cache', {
              p_city_id: city.id,
              p_region_text: regionCandidate
            })
            
            if (!error && regionMatches && regionMatches.length > 0) {
              const bestMatch = regionMatches[0]
              if (bestMatch.similarity_score >= 0.7) {
                region = {
                  id: bestMatch.alwaseet_id,
                  name: bestMatch.name,
                  original_id: bestMatch.alwaseet_id
                }
                console.log(`‚úÖ ŸÖŸÜÿ∑ŸÇÿ© ŸÖŸÜ ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸäÿØŸàŸä: ${region.name}`)
                break
              }
            }
          } catch (e) {
            console.error('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©:', e)
          }
        }
        if (region) break
      }
      
      if (!region && addressParts.length > (isDefaultCity ? 1 : 2)) {
        const regionText = addressParts.slice(isDefaultCity ? 1 : 1).join(' ')
        errors.push(`ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖŸÜÿ∑ŸÇÿ© "${regionText}" ŸÅŸä ŸÖÿØŸäŸÜÿ© ${city.name}`)
      }
    }
    
    return {
      customerName: customerName || undefined,
      city,
      region,
      remainingText: cacheResult.remaining_text || '',
      isDefaultCity,
      errors,
      suggestions
    }
    
  } catch (error) {
    console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉŸä:', error)
    errors.push('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿπŸÜŸàÿßŸÜ')
    
    return {
      city: null, region: null, remainingText: addressText, 
      isDefaultCity: false, errors, suggestions: {}
    }
  }
}

// Send comprehensive error message with smart suggestions
async function sendEnhancedErrorMessage(
  chatId: number, 
  originalText: string, 
  errors: string[], 
  suggestions: { cities?: any[], regions?: any[] },
  detectedData?: { city?: any, region?: any, isDefaultCity?: boolean }
): Promise<void> {
  let message = `‚ùå ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®:\n\n`
  
  // Show what was detected successfully
  if (detectedData?.city) {
    message += `‚úÖ ÿßŸÑŸÖÿØŸäŸÜÿ©: ${detectedData.city.name}`
    if (detectedData.isDefaultCity) {
      message += ` (ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ±Ÿáÿß ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã)`
    }
    message += `\n`
  }
  
  if (detectedData?.region) {
    message += `‚úÖ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©: ${detectedData.region.name}\n`
  }
  
  // Show errors
  if (errors.length > 0) {
    message += `\n‚ö†Ô∏è ŸÖÿ¥ÿßŸÉŸÑ ŸÅŸä ÿßŸÑÿ∑ŸÑÿ®:\n`
    errors.forEach((error, index) => {
      message += `${index + 1}. ${error}\n`
    })
  }
  
  // Show city suggestions
  if (suggestions.cities && suggestions.cities.length > 0) {
    message += `\nüèôÔ∏è ŸáŸÑ ÿ™ŸÇÿµÿØ ÿ•ÿ≠ÿØŸâ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿØŸÜÿü\n`
    suggestions.cities.slice(0, 5).forEach((city, index) => {
      message += `${index + 1}. ${city.name}\n`
    })
  }
  
  // Show region suggestions  
  if (suggestions.regions && suggestions.regions.length > 0) {
    message += `\nüèòÔ∏è ŸÖŸÜÿßÿ∑ŸÇ ŸÖŸÇÿ™ÿ±ÿ≠ÿ©:\n`
    suggestions.regions.slice(0, 5).forEach((region, index) => {
      message += `${index + 1}. ${region.name}\n`
    })
  }
  
  message += `\nüìù ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸä:\n${originalText}\n\n`
  message += `üîß ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑÿµÿ≠Ÿäÿ≠:\n`
  message += `ÿßÿ≥ŸÖ ÿßŸÑÿ≤ÿ®ŸàŸÜ\n`
  message += `ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ (07xxxxxxxxx)\n`
  message += `ÿßŸÑŸÖÿØŸäŸÜÿ© ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© (ÿ£Ÿà ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ŸÅŸÇÿ∑ ŸÑŸÑÿ®ÿ∫ÿØÿßÿØ)\n`
  message += `ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ ÿßŸÑŸÑŸàŸÜ ÿßŸÑŸÖŸÇÿßÿ≥\n\n`
  
  message += `ŸÖÿ´ÿßŸÑ ÿµÿ≠Ÿäÿ≠:\n`
  message += `ÿ£ÿ≠ŸÖÿØ ÿπŸÑŸä\n`
  message += `07701234567\n`
  if (detectedData?.city) {
    message += `${detectedData.city.name} `
    message += detectedData.region ? detectedData.region.name : 'ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©'
  } else {
    message += `ÿ®ÿ∫ÿØÿßÿØ ÿßŸÑŸÉÿ±ÿßÿØÿ©`
  }
  message += `\nÿ®ÿ±ÿ¥ŸÑŸàŸÜÿ© ÿ£ÿ≤ÿ±ŸÇ XL`
  
  await sendTelegramMessage(chatId, message)
}

// Send region selection menu
async function sendRegionSelectionMenu(chatId: number, cityName: string, regions: any[], originalText: string): Promise<boolean> {
  let message = `üèôÔ∏è ÿßŸÑŸÖÿØŸäŸÜÿ©: ${cityName}\n\n`
  message += `üîç Ÿàÿ¨ÿØÿ™ ÿπÿØÿ© ŸÖŸÜÿßÿ∑ŸÇ ŸÖÿ¥ÿßÿ®Ÿáÿ©:\n\n`
  
  regions.forEach((region, index) => {
    message += `${index + 1}) ${region.name}\n`
  })
  
  message += `\nüìù ÿßŸÉÿ™ÿ®: ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©: [ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠]\n`
  message += `ŸÖÿ´ÿßŸÑ: ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©: ${regions[0].name}\n\n`
  message += `üìã ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸä: ${originalText}`
  
  await sendTelegramMessage(chatId, message)
  return true
}

// Store pending order for region selection
const pendingOrders = new Map()

// Process region selection response
async function processRegionSelection(text: string, chatId: number): Promise<boolean> {
  const regionMatch = text.match(/ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©:\s*(.+)/i)
  if (!regionMatch) return false
  
  const selectedRegionName = regionMatch[1].trim()
  const pendingOrder = pendingOrders.get(chatId)
  
  if (!pendingOrder) {
    await sendTelegramMessage(chatId, '‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ ÿ∑ŸÑÿ® ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©')
    return false
  }
  
  // Find the selected region
  const selectedRegion = pendingOrder.regions.find((r: any) => 
    normalizeArabic(r.name) === normalizeArabic(selectedRegionName) ||
    normalizeArabic(r.name).includes(normalizeArabic(selectedRegionName))
  )
  
  if (!selectedRegion) {
    await sendTelegramMessage(chatId, `‚ùå ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© "${selectedRegionName}" ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿπÿ±Ÿàÿ∂ÿ©.`)
    return false
  }
  
  // Update pending order with selected region
  pendingOrder.customerRegion = selectedRegion
  pendingOrder.customerAddress = pendingOrder.remainingText || pendingOrder.customerAddress
  
  // Clear pending order and process
  pendingOrders.delete(chatId)
  
  // Continue with order processing
  return await completeOrderProcessing(pendingOrder, chatId)
}

// Complete order processing after region selection
async function completeOrderProcessing(orderData: any, chatId: number): Promise<boolean> {
  try {
    const employeeData = await supabase.rpc('get_employee_by_telegram_id', { 
      p_telegram_chat_id: chatId 
    })
    const employee = employeeData.data?.[0]
    
    if (!employee) return false
    
    // Get delivery fee
    const { data: settingsData } = await supabase
      .from('settings')
      .select('value')
      .eq('key', 'delivery_fee')
      .single()
    
    const defaultDeliveryFee = Number(settingsData?.value) || 5000
    
    // Calculate total
    const totalPrice = orderData.items.reduce((sum: number, item: any) => 
      sum + (item.price * item.quantity), 0)
    
    // Create order confirmation message
    const employeeInfo = employee ? 
      `${employee.full_name} (${employee.role}) - ${employee.employee_code}` : 
      `@${employee.employee_code}`
      
    const orderSummary = `
üîπ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑÿ¨ÿØŸäÿØ üîπ

üë§ ÿßŸÑÿπŸÖŸäŸÑ: ${orderData.customerName}
üì± ÿßŸÑŸáÿßÿ™ŸÅ: ${orderData.customerPhone}${orderData.customerSecondaryPhone ? `\nüì± ÿßŸÑŸáÿßÿ™ŸÅ ÿßŸÑÿ´ÿßŸÜŸä: ${orderData.customerSecondaryPhone}` : ''}
üèôÔ∏è ÿßŸÑŸÖÿØŸäŸÜÿ©: ${orderData.customerCity?.name || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}
üìç ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©: ${orderData.customerRegion?.name || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}
üè† ÿßŸÑÿπŸÜŸàÿßŸÜ: ${orderData.customerAddress || ''}

üì¶ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™:
${orderData.items.map((item: any) => `‚Ä¢ ${item.name} - ŸÉŸÖŸäÿ©: ${item.quantity} - ÿ≥ÿπÿ±: ${item.price.toLocaleString()} ÿØ.ÿπ`).join('\n')}

üí∞ ÿßŸÑŸÖÿ¨ŸÖŸàÿπ: ${totalPrice.toLocaleString()} ÿØ.ÿπ
üöö ÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ™ŸàÿµŸäŸÑ: ${defaultDeliveryFee.toLocaleString()} ÿØ.ÿπ
üí≥ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: ${(totalPrice + defaultDeliveryFee).toLocaleString()} ÿØ.ÿπ

üìã ÿßŸÑŸÖÿπÿ±ŸÅ: #TG_${Date.now().toString().slice(-6)}
üë®‚Äçüíº ÿ®Ÿàÿßÿ≥ÿ∑ÿ©: ${employeeInfo}

‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ∑ŸÑÿ® ÿ®ŸÜÿ¨ÿßÿ≠ ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ
‚è≥ ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± ŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ•ÿØÿßÿ±ÿ© ŸÑŸÑŸÖŸàÿßŸÅŸÇÿ© ŸàÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
    `.trim()
    
    // Save order to database
    const orderId = await supabase.rpc('process_telegram_order', {
      p_order_data: {
        customer_name: orderData.customerName,
        customer_phone: orderData.customerPhone,
        customer_secondary_phone: orderData.customerSecondaryPhone,
        customer_address: orderData.customerAddress,
        customer_city: orderData.customerCity?.name,
        customer_region: orderData.customerRegion?.name,
        items: orderData.items,
        total_price: totalPrice,
        delivery_fee: defaultDeliveryFee,
        final_total: totalPrice + defaultDeliveryFee,
        delivery_type: orderData.deliveryType,
        order_notes: orderData.orderNotes,
        telegram_chat_id: chatId,
        processed_at: new Date().toISOString(),
        original_text: `${orderData.customerName}\n${orderData.customerPhone}\n${orderData.items.map(i => i.name).join(', ')}`
      },
      p_employee_code: employee.employee_code,
      p_chat_id: chatId
    })
    
    if (orderId.error) {
      console.error('Database error:', orderId.error)
      await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ∑ŸÑÿ® ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
      return false
    }
    
    // Send confirmation
    await sendTelegramMessage(chatId, orderSummary)
    return true
    
  } catch (error) {
    console.error('Error completing order:', error)
    await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
    return false
  }
}

// Helper function to validate customer name
function isValidCustomerName(name: string): boolean {
  const trimmed = name.trim()
  // ÿ±ŸÅÿ∂ ÿßŸÑÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑŸÅÿßÿ±ÿ∫ÿ© ÿ£Ÿà ÿßŸÑŸÇÿµŸäÿ±ÿ© ÿ¨ÿØÿßŸã
  if (!trimmed || trimmed.length < 2) return false
  // ÿ±ŸÅÿ∂ ÿßŸÑÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ£ÿ±ŸÇÿßŸÖ ŸÅŸÇÿ∑
  if (/^\d+$/.test(trimmed)) return false
  // ÿ±ŸÅÿ∂ ÿßŸÑÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ±ŸÖŸàÿ≤ ÿ∫Ÿäÿ± ŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÅŸÇÿ∑
  if (/^[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]+$/.test(trimmed)) return false
  // ÿ±ŸÅÿ∂ ÿßŸÑÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ£ÿ±ŸÇÿßŸÖ ŸáŸàÿßÿ™ŸÅ
  if (/07[5789]\d{8}/.test(trimmed)) return false
  // ÿ±ŸÅÿ∂ ÿßŸÑÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ™Ÿä ÿ™ÿ®ÿØŸà ŸÖÿ´ŸÑ ÿπŸÜÿßŸàŸäŸÜ (ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖÿØŸÜ ÿπÿ±ÿßŸÇŸäÿ© ÿ¥ÿßÿ¶ÿπÿ©)
  const addressWords = ['ÿ®ÿ∫ÿØÿßÿØ', 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'ÿßÿ±ÿ®ŸäŸÑ', 'ÿØŸáŸàŸÉ', 'ŸÉÿ±ÿ®ŸÑÿßÿ°', 'ÿßŸÑŸÜÿ¨ŸÅ', 'ÿßŸÑÿßŸÜÿ®ÿßÿ±', 'ŸÜŸäŸÜŸàŸâ', 'ÿµŸÑÿßÿ≠ ÿßŸÑÿØŸäŸÜ', 'ÿßŸÑŸÇÿßÿØÿ≥Ÿäÿ©', 'ÿ®ÿßÿ®ŸÑ', 'Ÿàÿßÿ≥ÿ∑', 'ÿ∞Ÿä ŸÇÿßÿ±', 'ÿßŸÑŸÖÿ´ŸÜŸâ', 'ŸÖŸäÿ≥ÿßŸÜ', 'ÿßŸÑÿØŸàÿ±ÿ©', 'ÿßŸÑŸÉÿ±ÿßÿØÿ©', 'ÿßŸÑŸÖŸÜÿµŸàÿ±', 'ÿßŸÑŸÉÿßÿ∏ŸÖŸäÿ©', 'ÿßŸÑÿßÿπÿ∏ŸÖŸäÿ©', 'ÿßŸÑÿ≠ŸÑÿ©', 'ŸÉÿ±ŸÉŸàŸÉ', 'ÿ™ŸÉÿ±Ÿäÿ™', 'ÿßŸÑÿ±ŸÖÿßÿØŸä', 'ÿßŸÑŸÅŸÑŸàÿ¨ÿ©', 'ÿßŸÑŸÖŸàÿµŸÑ', 'ÿßŸÑÿ≥ŸÖÿßŸàÿ©', 'ÿßŸÑÿØŸäŸàÿßŸÜŸäÿ©', 'ÿßŸÑÿπŸÖÿßÿ±ÿ©', 'ÿßŸÑŸÜÿßÿµÿ±Ÿäÿ©']
  const lowerName = trimmed.toLowerCase()
  if (addressWords.some(word => lowerName.includes(word.toLowerCase()))) return false
  // ÿ±ŸÅÿ∂ ÿßŸÑÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÉŸÑŸÖÿßÿ™ ÿπŸÜÿßŸàŸäŸÜ ÿ¥ÿßÿ¶ÿπÿ©
  if (/\b(ÿ¥ÿßÿ±ÿπ|ÿ≠Ÿä|ŸÖŸÜÿ∑ŸÇÿ©|ŸÇÿ±ÿ®|ŸÖŸÇÿßÿ®ŸÑ|ÿ¨ÿßŸÜÿ®|ŸÖÿ≠ŸÑÿ©|ÿµÿ≠ÿ©|ŸÖÿ≥ÿ™ÿ¥ŸÅŸâ|ÿ¨ÿßŸÖÿπ|ŸÖÿØÿ±ÿ≥ÿ©|ŸÖŸàŸÑ|ÿ≥ŸàŸÇ)\b/i.test(trimmed)) return false
  return true
}

// Enhanced order processing with improved error handling
async function processOrderWithAlWaseet(text: string, chatId: number, employeeCode: string) {
  try {
    const lines = text.split('\n').filter(line => line.trim())
    
    let customerName = ''
    let customerPhone = ''
    let customerSecondaryPhone = ''
    let customerAddress = ''
    let customerCity = null
    let customerRegion = null
    let items = []
    let totalPrice = 0
    let hasCustomPrice = false
    let deliveryType = 'ÿ™ŸàÿµŸäŸÑ'
    let orderNotes = ''
    let orderErrors: string[] = []
    let isDefaultCity = false
    
    // Get default settings
    const { data: settingsData } = await supabase
      .from('settings')
      .select('value')
      .eq('key', 'delivery_fee')
      .single()
    
    const defaultDeliveryFee = Number(settingsData?.value) || 5000
    
    // Get employee info
    const employeeData = await supabase.rpc('get_employee_by_telegram_id', { 
      p_telegram_chat_id: chatId 
    })
    const employee = employeeData.data?.[0]
    
    if (!employee) {
      console.error('No employee found for chat ID:', chatId)
      return false
    }
    
    const { data: profileData } = await supabase
      .from('profiles')
      .select('default_customer_name')
      .eq('user_id', employee.user_id)
      .single()
    
    const defaultCustomerName = profileData?.default_customer_name || 'ÿ≤ÿ®ŸàŸÜ ŸÖŸÜ ÿßŸÑÿ™ŸÑŸäÿ∫ÿ±ÿßŸÖ'
    
    let phoneFound = false
    let cityFound = false
    
    // Enhanced smart parsing of entire order text first
    console.log(`üß† ÿ®ÿØÿ° ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉŸä ÿßŸÑÿ¥ÿßŸÖŸÑ ŸÑŸÑÿ∑ŸÑÿ®`)
    const globalSmartResult = await parseAddressLineSmart(text)
    
    // Use global smart result if we found comprehensive data
    if (globalSmartResult.city && globalSmartResult.customerName) {
      customerName = globalSmartResult.customerName
      customerCity = globalSmartResult.city
      isDefaultCity = globalSmartResult.isDefaultCity
      if (globalSmartResult.region) {
        customerRegion = globalSmartResult.region
      }
      customerAddress = globalSmartResult.remainingText
      
      console.log(`‚úÖ ŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉŸä ÿßŸÑÿ¥ÿßŸÖŸÑ:`, {
        name: customerName,
        city: customerCity.name,
        region: customerRegion?.name,
        isDefault: isDefaultCity
      })
      
      if (globalSmartResult.errors.length > 0 && globalSmartResult.suggestions.cities) {
        await sendEnhancedErrorMessage(
          chatId, 
          text, 
          globalSmartResult.errors, 
          globalSmartResult.suggestions,
          { city: customerCity, region: customerRegion, isDefaultCity }
        )
        return true
      }
    }
    
    // Parse order text line by line for additional details
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim()
      const lowerLine = line.toLowerCase()
      
      // Parse customer name - improved detection with validation
      if ((lowerLine.includes('ÿßÿ≥ŸÖ') || lowerLine.includes('ÿ≤ÿ®ŸàŸÜ') || lowerLine.includes('ÿπŸÖŸäŸÑ') || lowerLine.includes('ÿßŸÑÿ≤ÿ®ŸàŸÜ')) && !customerName) {
        const extractedName = line.replace(/^(ÿßÿ≥ŸÖ|ÿ≤ÿ®ŸàŸÜ|ÿπŸÖŸäŸÑ|ÿßŸÑÿ≤ÿ®ŸàŸÜ)[:\s]*/i, '').trim()
        if (isValidCustomerName(extractedName)) {
          customerName = extractedName
        }
      } else if (i === 0 && !customerName && !line.match(/07[5789]\d{8}/) && !lowerLine.includes('ŸÖŸÜÿ™ÿ¨') && isValidCustomerName(line)) {
        // First line as customer name only if it's a valid name
        customerName = line.trim()
      }
      
      // Parse phone numbers
      const phoneRegex = /(?:07[5789]\d{8,9})/g
      const phoneMatches = line.match(phoneRegex)
      if (phoneMatches && !phoneFound) {
        customerPhone = phoneMatches[0]
        if (phoneMatches[1]) customerSecondaryPhone = phoneMatches[1]
        phoneFound = true
      }
      
      // Parse address with enhanced city detection (if not already found globally)
      if ((lowerLine.includes('ÿπŸÜŸàÿßŸÜ') || lowerLine.includes('ŸÖŸÜÿ∑ŸÇÿ©') || lowerLine.includes('ŸÖÿ≠ŸÑÿ©')) && !customerAddress) {
        customerAddress = line.replace(/^(ÿπŸÜŸàÿßŸÜ|ŸÖŸÜÿ∑ŸÇÿ©|ŸÖÿ≠ŸÑÿ©)[:\s]*/i, '').trim()
      }
      
      // Parse city explicitly (if not already found globally)
      if ((lowerLine.includes('ŸÖÿØŸäŸÜÿ©') || lowerLine.includes('ŸÖÿ≠ÿßŸÅÿ∏ÿ©')) && !cityFound && !customerCity) {
        const cityText = line.replace(/^(ŸÖÿØŸäŸÜÿ©|ŸÖÿ≠ÿßŸÅÿ∏ÿ©)[:\s]*/i, '').trim()
        const cityResult = await findCityByNameSmart(cityText)
        customerCity = cityResult.city
        
        if (!customerCity && cityResult.suggestions.length > 0) {
          await sendEnhancedErrorMessage(
            chatId, 
            text, 
            [`ÿßŸÑŸÖÿØŸäŸÜÿ© "${cityText}" ÿ∫Ÿäÿ± Ÿàÿßÿ∂ÿ≠ÿ©`], 
            { cities: cityResult.suggestions }
          )
          return true
        }
        cityFound = true
      }
      
      // Smart address parsing with enhanced intelligence
      if (!cityFound && !customerAddress && !phoneMatches && !lowerLine.includes('ŸÖŸÜÿ™ÿ¨') && 
          !isValidCustomerName(line) && line.length > 3) {
        
        console.log(`üß† ÿ™ÿ≠ŸÑŸäŸÑ ÿ∞ŸÉŸä ŸÑŸÑÿ≥ÿ∑ÿ±: "${line}"`)
        const smartResult = await parseAddressLineSmart(line)
        
        if (smartResult.city) {
          customerCity = smartResult.city
          isDefaultCity = smartResult.isDefaultCity
          
          if (smartResult.region) {
            customerRegion = smartResult.region
            customerAddress = smartResult.remainingText || line
            console.log(`‚úÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿ∞ŸÉŸä ŸÉÿßŸÖŸÑ: ${customerCity.name} - ${customerRegion.name}`)
          } else {
            customerAddress = smartResult.remainingText || line
            console.log(`‚úÖ ÿ™ÿ≠ŸÑŸäŸÑ ÿ∞ŸÉŸä ŸÑŸÑŸÖÿØŸäŸÜÿ© ŸÅŸÇÿ∑: ${customerCity.name}`)
          }
          
          if (smartResult.customerName && !customerName) {
            customerName = smartResult.customerName
            console.log(`üë§ ÿßÿ≥ŸÖ ÿßŸÑÿ≤ÿ®ŸàŸÜ ŸÖŸÜ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉŸä: ${customerName}`)
          }
          
          if (isDefaultCity) {
            console.log(`üèôÔ∏è ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿØŸäŸÜÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© ÿ®ÿ∞ŸÉÿßÿ°: ${customerCity.name}`)
          }
        }
        
        // Handle errors with smart suggestions
        if (smartResult.errors.length > 0) {
          console.log(`‚ö†Ô∏è ÿ£ÿÆÿ∑ÿßÿ° ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉŸä:`, smartResult.errors)
          orderErrors.push(...smartResult.errors)
          
          // If we have suggestions, this means there were issues that need user clarification
          if (smartResult.suggestions.cities && smartResult.suggestions.cities.length > 0) {
            await sendEnhancedErrorMessage(
              chatId, 
              text, 
              smartResult.errors, 
              smartResult.suggestions,
              { city: smartResult.city, region: smartResult.region, isDefaultCity: smartResult.isDefaultCity }
            )
            return true // Stop processing this order due to errors
          }
        }
        
        cityFound = true
      }
      
      // Product parsing
      if (!phoneMatches && !lowerLine.includes('ŸÖŸÜÿ∑ŸÇÿ©') && !lowerLine.includes('ŸÖÿØŸäŸÜÿ©') && 
          !lowerLine.includes('ÿπŸÜŸàÿßŸÜ') && !isValidCustomerName(line) && line.length > 2) {
        
        // Enhanced product search
        const searchTerms = createFlexibleSearchTerms(line)
        let foundProduct = null
        
        for (const term of searchTerms) {
          const { data: products, error } = await supabase
            .from('products')
            .select('*')
            .ilike('name', `%${term}%`)
            .eq('is_active', true)
            .limit(1)
          
          if (products && products.length > 0) {
            foundProduct = products[0]
            console.log(`‚úÖ Found product with term "${term}":`, foundProduct.name)
            break
          }
        }
        
        if (foundProduct) {
          items.push({
            id: foundProduct.id,
            name: foundProduct.name,
            price: foundProduct.price,
            quantity: 1
          })
          totalPrice += foundProduct.price
        } else {
          console.log(`‚ùå Product not found for: "${line}"`)
        }
      }
    }
    
    // Enhanced validation and error handling
    if (!customerName) customerName = defaultCustomerName
    
    if (!customerPhone) {
      orderErrors.push('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±ŸÇŸÖ Ÿáÿßÿ™ŸÅ ÿµÿßŸÑÿ≠ (Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ®ÿØÿ£ ÿ®ŸÄ 07)')
    }
    
    if (!customerCity) {
      orderErrors.push('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿØŸäŸÜÿ© ÿ®Ÿàÿ∂Ÿàÿ≠')
    }
    
    if (items.length === 0) {
      orderErrors.push('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ£Ÿä ŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸÅŸä ÿßŸÑÿ∑ŸÑÿ®')
    }
    
    // If there are critical errors, send enhanced error message
    if (orderErrors.length > 0) {
      console.log('‚ùå ÿ£ÿÆÿ∑ÿßÿ° ŸÅŸä ÿßŸÑÿ∑ŸÑÿ®:', orderErrors)
      await sendEnhancedErrorMessage(
        chatId, 
        text, 
        orderErrors, 
        {},
        { city: customerCity, region: customerRegion, isDefaultCity }
      )
      return true
    }
    
    if (!customerCity) {
      orderErrors.push('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿØŸäŸÜÿ© ÿ®Ÿàÿ∂Ÿàÿ≠')
    }
    
    if (items.length === 0) {
      orderErrors.push('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ£Ÿä ŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿµÿßŸÑÿ≠ÿ©')
    }
    
    // If there are errors, send detailed error message
    if (orderErrors.length > 0) {
      let suggestions = []
      if (!customerCity) {
        // Try to get city suggestions from first non-phone line
        const addressLine = lines.find(line => 
          !line.match(/07[5789]\d{8}/) && 
          !isValidCustomerName(line) && 
          line.length > 3
        )
        if (addressLine) {
          const cityResult = await findCityByName(addressLine.split(/[\s,ÿå]/)[0])
          suggestions = cityResult.suggestions
        }
      }
      
      await sendErrorMessageWithSuggestions(chatId, text, orderErrors, suggestions)
      return false
    }
    
    // Complete order processing
    const orderData = {
      customerName,
      customerPhone,
      customerSecondaryPhone,
      customerAddress: customerAddress || customerRegion?.name || '',
      customerCity,
      customerRegion,
      items,
      totalPrice,
      deliveryType,
      orderNotes
    }
    
    return await completeOrderProcessing(orderData, chatId)
    
  } catch (error) {
    console.error('Error processing order:', error)
    await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä.')
    return false
  }
}

// Simple welcome message
async function sendWelcomeMessage(chatId: number, employee: any) {
  const welcomeText = `
ŸÖÿ±ÿ≠ÿ®ÿßŸã ${employee.full_name}! üëã

ü§ñ ÿ£ŸÜÿß ÿ®Ÿàÿ™ ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
üìù ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿπŸÖŸÑÿßÿ° ÿ®ÿßŸÑÿ¥ŸÉŸÑ ÿßŸÑÿ™ÿßŸÑŸä:

ÿßÿ≥ŸÖ ÿßŸÑÿπŸÖŸäŸÑ
ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ
ÿßŸÑŸÖÿØŸäŸÜÿ© ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©
ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨

ŸÖÿ´ÿßŸÑ:
ÿ£ÿ≠ŸÖÿØ ÿπŸÑŸä
07701234567
ÿ®ÿ∫ÿØÿßÿØ ÿßŸÑŸÉÿ±ÿßÿØÿ©
ÿ®ÿ±ÿ¥ŸÑŸàŸÜÿ© ÿßÿ≤ÿ±ŸÇ ŸÖŸäÿØŸäŸÖ

‚ú® ÿßŸÑÿ®Ÿàÿ™ ŸäŸÅŸáŸÖ ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑŸÖÿØŸÜ ÿ®ÿ£ÿ¥ŸÉÿßŸÑ ŸÖÿÆÿ™ŸÑŸÅÿ©
üèôÔ∏è ŸäŸÖŸÉŸÜ ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ŸÅŸÇÿ∑ Ÿàÿ≥Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿ®ÿ∫ÿØÿßÿØ ŸÉÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
  `.trim()
  
  await sendTelegramMessage(chatId, welcomeText)
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const body = await req.json()
    console.log('üì® Received Telegram update:', JSON.stringify(body, null, 2))
    
    const message = body.message
    if (!message || !message.text) {
      console.log('‚ùå No message or text found')
      return new Response('No message', { headers: corsHeaders })
    }

    const chatId = message.chat.id
    const text = message.text.trim()
    const userId = message.from.id

    console.log(`üí¨ Processing message from chat ${chatId}: "${text}"`)

    // Get employee information
    const { data: employeeData, error: employeeError } = await supabase.rpc('get_employee_by_telegram_id', { 
      p_telegram_chat_id: chatId 
    })

    if (employeeError) {
      console.error('‚ùå Error fetching employee:', employeeError)
      await sendTelegramMessage(chatId, '‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
      return new Response('Error', { headers: corsHeaders })
    }

    const employee = employeeData?.[0]
    if (!employee) {
      console.log(`‚ùå No employee found for chat ID: ${chatId}`)
      await sendTelegramMessage(chatId, '‚ùå ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ŸÑŸÉ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ®Ÿàÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ•ÿØÿßÿ±ÿ©.')
      return new Response('Unauthorized', { headers: corsHeaders })
    }

    console.log(`üë§ Employee found: ${employee.full_name} (${employee.employee_code})`)

    // Handle commands
    if (text === '/start' || text === '/help') {
      await sendWelcomeMessage(chatId, employee)
      return new Response('OK', { headers: corsHeaders })
    }

    // Check for region selection response
    if (text.includes('ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©:')) {
      const regionProcessed = await processRegionSelection(text, chatId)
      if (regionProcessed) {
        return new Response('OK', { headers: corsHeaders })
      }
    }

    // Process order
    const orderProcessed = await processOrderWithAlWaseet(text, chatId, employee.employee_code)
    
    if (!orderProcessed) {
      console.log('‚ùå Order processing failed')
      // Error message already sent in processOrderWithAlWaseet
    }

    return new Response('OK', { headers: corsHeaders })
    
  } catch (error) {
    console.error('‚ùå Telegram bot error:', error)
    return new Response('Internal Server Error', { 
      status: 500,
      headers: corsHeaders 
    })
  }
})