import { serve } from "https://deno.land/std@0.208.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// Initialize Supabase client
const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
const supabase = createClient(supabaseUrl, supabaseServiceKey)

// Telegram Bot Token
const TELEGRAM_BOT_TOKEN = Deno.env.get('TELEGRAM_BOT_TOKEN')!

interface TelegramMessage {
  message_id: number
  from: {
    id: number
    first_name: string
    username?: string
  }
  chat: {
    id: number
    type: string
  }
  text: string
  date: number
}

interface TelegramUpdate {
  update_id: number
  message?: TelegramMessage
}

// Send message to Telegram
async function sendTelegramMessage(chatId: number, text: string) {
  const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      text: text,
      parse_mode: 'HTML'
    })
  })
  return response.json()
}

// Get cities from cache database (fast and updated)
async function getCitiesFromCache(): Promise<any[]> {
  try {
    const { data: cities, error } = await supabase
      .from('cities_cache')
      .select('id, name, original_id')
      .eq('is_active', true)
      .order('name')
    
    if (error) {
      console.error('Error fetching cities from cache:', error)
      return []
    }
    
    return cities || []
  } catch (error) {
    console.error('Error in getCitiesFromCache:', error)
    return []
  }
}

// Get regions by city from cache database (fast and updated)
async function getRegionsByCity(cityId: number): Promise<any[]> {
  try {
    const { data: regions, error } = await supabase
      .from('regions_cache')
      .select('id, name, original_id')
      .eq('city_id', cityId)
      .eq('is_active', true)
      .order('name')
    
    if (error) {
      console.error('Error fetching regions from cache:', error)
      return []
    }
    
    return regions || []
  } catch (error) {
    console.error('Error in getRegionsByCity:', error)
    return []
  }
}

// Enhanced Arabic text normalization for superior matching capabilities
function normalizeArabic(text: string): string {
  if (!text) return ''
  
  return text.toString().trim()
    // Remove common prefixes and suffixes
    .replace(/^(ÿßŸÑ|ŸÖÿ≠ÿßŸÅÿ∏ÿ©|ŸÖÿØŸäŸÜÿ©|ŸÇÿ∂ÿßÿ°|ŸÜÿßÿ≠Ÿäÿ©)\s+/g, '')
    .replace(/\s+(ŸÖÿ≠ÿßŸÅÿ∏ÿ©|ŸÇÿ∂ÿßÿ°|ŸÜÿßÿ≠Ÿäÿ©)$/g, '')
    // Enhanced Arabic letter normalization
    .replace(/[ÿ£ÿ•ÿ¢]/g, 'ÿß')
    .replace(/[ÿ©Ÿá]/g, 'Ÿá')
    .replace(/[ŸäŸâ]/g, 'Ÿä')
    .replace(/[ÿ§]/g, 'Ÿà')
    .replace(/[ÿ¶]/g, 'Ÿä')
    .replace(/[ÿ°]/g, '')
    // Handle diacritics completely
    .replace(/[\u064B-\u065F\u0670\u0640]/g, '')
    // Remove extra spaces and punctuation
    .replace(/[.,ÿåÿõ:]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase()
}

// Calculate string similarity for fuzzy matching
function calculateSimilarity(str1: string, str2: string): number {
  const longer = str1.length > str2.length ? str1 : str2
  const shorter = str1.length > str2.length ? str2 : str1
  
  if (longer.length === 0) return 1.0
  
  // Exact match
  if (longer === shorter) return 1.0
  
  // Contains check
  if (longer.includes(shorter) || shorter.includes(longer)) {
    return 0.8 + (shorter.length / longer.length) * 0.2
  }
  
  // Levenshtein distance
  const matrix = Array(longer.length + 1).fill(null).map(() => Array(shorter.length + 1).fill(null))
  
  for (let i = 0; i <= longer.length; i++) matrix[i][0] = i
  for (let j = 0; j <= shorter.length; j++) matrix[0][j] = j
  
  for (let i = 1; i <= longer.length; i++) {
    for (let j = 1; j <= shorter.length; j++) {
      const cost = longer[i - 1] === shorter[j - 1] ? 0 : 1
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      )
    }
  }
  
  const distance = matrix[longer.length][shorter.length]
  return 1.0 - (distance / longer.length)
}

// Fixed comprehensive city name variations with correct structure  
const cityNameVariations: { [standardName: string]: string[] } = {
  'ÿßŸÑÿØŸäŸàÿßŸÜŸäÿ©': ['ÿØŸäŸàÿßŸÜŸäÿ©', 'ÿßŸÑÿØŸäŸàÿßŸÜŸäÿ©', 'ÿØŸäŸàÿßŸÜŸäŸá', 'ÿßŸÑÿØŸäŸàÿßŸÜŸäŸá', 'ÿßŸÑŸÇÿßÿØÿ≥Ÿäÿ©', 'ÿßŸÑŸÇÿßÿØÿ≥ŸäŸá', 'ŸÇÿßÿØÿ≥Ÿäÿ©', 'qadisiyah', 'diwaniyah'],
  'ÿ®ÿ∫ÿØÿßÿØ': ['ÿ®ÿ∫ÿØÿßÿØ', 'Baghdad', 'baghdad', 'ÿ®ÿ∫ÿØÿØ', 'ÿ®ŸÇÿØÿßÿØ'],
  'ÿßŸÑÿ®ÿµÿ±ÿ©': ['ÿßŸÑÿ®ÿµÿ±Ÿá', 'ÿ®ÿµÿ±ÿ©', 'ÿ®ÿµÿ±Ÿá', 'ÿßŸÑÿ®ÿµÿ±ÿ©', 'basrah', 'basra'],
  'ÿßÿ±ÿ®ŸäŸÑ': ['ÿ£ÿ±ÿ®ŸäŸÑ', 'ÿßÿ±ÿ®ŸäŸÑ', 'ÿ£ÿ±ÿ®ŸäŸÑ', 'ÿßÿ±ÿ®ŸÑ', 'Erbil', 'erbil', 'ŸáŸàŸÑŸäÿ±'],
  'ÿØŸáŸàŸÉ': ['ÿØŸáŸàŸÉ', 'ÿØŸáŸÉ', 'Dohuk', 'dohuk', 'dahuk'],
  'ŸÉÿ±ÿ®ŸÑÿßÿ°': ['ŸÉÿ±ÿ®ŸÑÿßÿ°', 'ŸÉÿ±ÿ®ŸÑÿß', 'ŸÉÿ±ÿ®ŸÑŸá', 'Karbala', 'karbala'],
  'ÿßŸÑŸÜÿ¨ŸÅ': ['ÿßŸÑŸÜÿ¨ŸÅ', 'ŸÜÿ¨ŸÅ', 'ŸÜÿ¨ÿßŸÅ', 'Najaf', 'najaf'],
  'ŸÜŸäŸÜŸàŸâ': ['ŸÜŸäŸÜŸàŸâ', 'ŸÜŸäŸÜŸàÿß', 'ÿßŸÑŸÖŸàÿµŸÑ', 'ŸÖŸàÿµŸÑ', 'ŸÜŸäŸÜŸàŸá', 'Nineveh', 'nineveh', 'mosul'],
  'ÿµŸÑÿßÿ≠ ÿßŸÑÿØŸäŸÜ': ['ÿµŸÑÿßÿ≠ ÿßŸÑÿØŸäŸÜ', 'ÿµŸÑÿßÿ≠ÿØŸäŸÜ', 'ÿ™ŸÉÿ±Ÿäÿ™', 'ÿ™ŸÉÿ±ÿ™', 'salahuddin', 'tikrit'],
  'ÿßŸÑÿ£ŸÜÿ®ÿßÿ±': ['ÿßŸÑÿ£ŸÜÿ®ÿßÿ±', 'ÿßŸÑÿßŸÜÿ®ÿßÿ±', 'ÿßŸÜÿ®ÿßÿ±', 'ÿ£ŸÜÿ®ÿßÿ±', 'ÿßŸÑÿ±ŸÖÿßÿØŸä', 'ÿ±ŸÖÿßÿØŸä', 'anbar', 'ramadi'],
  'ÿ®ÿßÿ®ŸÑ': ['ÿ®ÿßÿ®ŸÑ', 'ÿßŸÑÿ≠ŸÑÿ©', 'ÿ≠ŸÑÿ©', 'ÿ≠ŸÑŸá', 'babylon', 'hillah', 'hilla'],
  'Ÿàÿßÿ≥ÿ∑': ['Ÿàÿßÿ≥ÿ∑', 'ÿßŸÑŸÉŸàÿ™', 'ŸÉŸàÿ™', 'ŸÉÿ™', 'Wasit', 'wasit', 'kut'],
  'ÿ∞Ÿä ŸÇÿßÿ±': ['ÿ∞Ÿä ŸÇÿßÿ±', 'ÿ∞ŸäŸÇÿßÿ±', 'ÿßŸÑŸÜÿßÿµÿ±Ÿäÿ©', 'ŸÜÿßÿµÿ±Ÿäÿ©', 'ŸÜÿßÿµÿ±ŸäŸá', 'thi qar', 'nasiriyah'],
  'ÿßŸÑŸÖÿ´ŸÜŸâ': ['ÿßŸÑŸÖÿ´ŸÜŸâ', 'ŸÖÿ´ŸÜŸâ', 'ÿßŸÑÿ≥ŸÖÿßŸàÿ©', 'ÿ≥ŸÖÿßŸàÿ©', 'ÿ≥ŸÖÿßŸàŸá', 'muthanna', 'samawah'],
  'ŸÖŸäÿ≥ÿßŸÜ': ['ŸÖŸäÿ≥ÿßŸÜ', 'ÿßŸÑÿπŸÖÿßÿ±ÿ©', 'ÿπŸÖÿßÿ±ÿ©', 'ÿπŸÖÿßÿ±Ÿá', 'Maysan', 'maysan', 'amarah'],
  'ŸÉÿ±ŸÉŸàŸÉ': ['ŸÉÿ±ŸÉŸàŸÉ', 'ŸÉÿ±ŸÉŸÉ', 'Kirkuk', 'kirkuk'],
  'ÿßŸÑÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©': ['ÿßŸÑÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©', 'ÿ≥ŸÑŸäŸÖÿßŸÜŸäÿ©', 'ÿ≥ŸÑŸäŸÖÿßŸÜŸäŸá', 'Sulaymaniyah', 'sulaymaniyah'],
  'ÿ≠ŸÑÿ®ÿ¨ÿ©': ['ÿ≠ŸÑÿ®ÿ¨ÿ©', 'ÿ≠ŸÑÿ®ÿ¨Ÿá', 'halabja', 'halabcha']
}

// Enhanced city finder with improved variation matching
function findCityByVariation(searchTerm: string): string | null {
  const normalizedSearch = normalizeArabic(searchTerm)
  
  for (const [standardName, variations] of Object.entries(cityNameVariations)) {
    // Check if search matches standard name
    if (normalizeArabic(standardName).includes(normalizedSearch) || 
        normalizedSearch.includes(normalizeArabic(standardName))) {
      return standardName
    }
    
    // Check variations
    for (const variation of variations) {
      const normalizedVariation = normalizeArabic(variation)
      if (normalizedVariation === normalizedSearch || 
          normalizedVariation.includes(normalizedSearch) ||
          normalizedSearch.includes(normalizedVariation)) {
        return standardName
      }
    }
  }
  
  return null
}

// Enhanced flexible product search that handles both ÿ© and Ÿá with detailed logging
function createFlexibleSearchTerms(productName: string): string[] {
  const normalized = normalizeArabic(productName)
  const terms = [
    productName,
    normalized,
    productName.replace(/ÿ©/g, 'Ÿá'),
    productName.replace(/Ÿá/g, 'ÿ©'),
    normalized.replace(/ÿ©/g, 'Ÿá'),
    normalized.replace(/Ÿá/g, 'ÿ©')
  ]
  
  // Add partial matching for single words
  const words = productName.split(/\s+/);
  if (words.length === 1 && words[0].length >= 3) {
    terms.push(words[0]);
    terms.push(normalizeArabic(words[0]));
  }
  
  const uniqueTerms = [...new Set(terms)]
  console.log(`üîç Search terms for "${productName}":`, uniqueTerms)
  return uniqueTerms
}

// Map to store pending orders temporarily
const pendingOrders = new Map()

// Enhanced product search with variant and inventory checking
async function searchProductWithVariantsAndInventory(line: string, chatId: number, customerPhone?: string): Promise<{
  found: boolean,
  available: boolean,
  product?: any,
  variant?: any,
  stockAlert?: string
}> {
  try {
    console.log(`üîç ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ≠ÿ≥ŸÜ ÿπŸÜ ÿßŸÑŸÖŸÜÿ™ÿ¨: "${line}"`)
    
    // Parse product details (name, color, size) from the line
    const productDetails = parseProductDetails(line)
    console.log(`üìã ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÖŸÜÿ™ÿ¨ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿ±ÿ¨ÿ©:`, productDetails)
    
    // Search for products using flexible terms
    const searchTerms = createFlexibleSearchTerms(productDetails.name)
    let foundProduct = null
    
    for (const term of searchTerms) {
      const { data: products, error } = await supabase
        .from('products')
        .select(`
          *,
          variants:product_variants(
            *,
            color:colors(id, name),
            size:sizes(id, name),
            inventory(quantity, reserved_quantity, min_stock)
          )
        `)
        .ilike('name', `%${term}%`)
        .eq('is_active', true)
        .limit(1)
      
      if (products && products.length > 0) {
        foundProduct = products[0]
        console.log(`‚úÖ ÿπÿ´ÿ± ÿπŸÑŸâ ŸÖŸÜÿ™ÿ¨: "${foundProduct.name}" ÿ®ÿßŸÑŸÖÿµÿ∑ŸÑÿ≠ "${term}"`)
        break
      }
    }
    
    if (!foundProduct) {
      return { found: false, available: false }
    }
    
    // Find matching variant if color/size specified
    let selectedVariant = null
    if (foundProduct.variants && foundProduct.variants.length > 0) {
      
      // Look for exact color/size match
      for (const variant of foundProduct.variants) {
        const colorMatch = !productDetails.color || 
          normalizeArabic(variant.color?.name || '').includes(normalizeArabic(productDetails.color)) ||
          normalizeArabic(productDetails.color).includes(normalizeArabic(variant.color?.name || ''))
        
        const sizeMatch = !productDetails.size || 
          normalizeArabic(variant.size?.name || '').includes(normalizeArabic(productDetails.size)) ||
          normalizeArabic(productDetails.size).includes(normalizeArabic(variant.size?.name || ''))
        
        if (colorMatch && sizeMatch) {
          selectedVariant = variant
          console.log(`‚úÖ ŸÖÿ™ÿ∫Ÿäÿ± ŸÖÿ∑ÿßÿ®ŸÇ: ${variant.color?.name} ${variant.size?.name}`)
          break
        }
      }
      
      // If no exact match but we have a color/size requirement, check availability and send alert
      if (!selectedVariant && (productDetails.color || productDetails.size)) {
        console.log(`‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ™ÿ∫Ÿäÿ± ŸÖÿ∑ÿßÿ®ŸÇ ŸÑŸÑŸÄ ${productDetails.color} ${productDetails.size}`)
        
        // Generate stock alert for unavailable variant
        const phone = customerPhone || await extractPhoneFromContext(chatId)
        const stockAlert = generateStockAlert(foundProduct, productDetails, phone)
        
        return {
          found: true,
          available: false,
          product: foundProduct,
          stockAlert: stockAlert
        }
      }
      
      // If no color/size specified, pick first available variant
      if (!selectedVariant) {
        selectedVariant = foundProduct.variants.find(v => 
          v.inventory && v.inventory.length > 0 && v.inventory[0].quantity > 0
        ) || foundProduct.variants[0]
      }
    }
    
    // Check inventory availability
    let isAvailable = true
    let stockQuantity = 0
    
    if (selectedVariant && selectedVariant.inventory && selectedVariant.inventory.length > 0) {
      const inventory = selectedVariant.inventory[0]
      stockQuantity = inventory.quantity - (inventory.reserved_quantity || 0)
      isAvailable = stockQuantity > 0
      
      console.log(`üì¶ ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ: ÿßŸÑŸÉŸÖŸäÿ© ${inventory.quantity}, ÿßŸÑŸÖÿ≠ÿ¨Ÿàÿ≤ ${inventory.reserved_quantity}, ÿßŸÑŸÖÿ™ÿßÿ≠ ${stockQuantity}`)
    }
    
    // If not available, generate stock alert
    if (!isAvailable) {
      const phone = customerPhone || await extractPhoneFromContext(chatId)
      const stockAlert = generateStockAlert(foundProduct, productDetails, phone, selectedVariant)
      
      return {
        found: true,
        available: false,
        product: foundProduct,
        variant: selectedVariant,
        stockAlert: stockAlert
      }
    }
    
    return {
      found: true,
      available: true,
      product: foundProduct,
      variant: selectedVariant ? {
        ...selectedVariant,
        stock: stockQuantity
      } : null
    }
    
  } catch (error) {
    console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ≠ÿ≥ŸÜ ÿπŸÜ ÿßŸÑŸÖŸÜÿ™ÿ¨:', error)
    return { found: false, available: false }
  }
}

// Parse product details (name, color, size) from text
function parseProductDetails(text: string): { name: string, color?: string, size?: string } {
  const normalizedText = text.trim()
  
  // Common colors in Arabic and English
  const colors = [
    'ÿßÿ≠ŸÖÿ±', 'ÿ£ÿ≠ŸÖÿ±', 'red', 'ÿßÿ≤ÿ±ŸÇ', 'ÿ£ÿ≤ÿ±ŸÇ', 'blue', 'ÿßÿµŸÅÿ±', 'ÿ£ÿµŸÅÿ±', 'yellow',
    'ÿßÿÆÿ∂ÿ±', 'ÿ£ÿÆÿ∂ÿ±', 'green', 'ÿßÿ≥ŸàÿØ', 'ÿ£ÿ≥ŸàÿØ', 'black', 'ÿßÿ®Ÿäÿ∂', 'ÿ£ÿ®Ÿäÿ∂', 'white',
    'Ÿàÿ±ÿØŸä', 'pink', 'ÿ®ŸÜŸÅÿ≥ÿ¨Ÿä', 'purple', 'ÿ®ÿ±ÿ™ŸÇÿßŸÑŸä', 'orange', 'ÿ®ŸÜŸä', 'brown',
    'ÿ±ŸÖÿßÿØŸä', 'gray', 'grey', 'ÿ≥ŸÖÿßÿ¶Ÿä', 'ŸÅŸäÿ±Ÿàÿ≤Ÿä', 'turquoise', 'ÿ∞Ÿáÿ®Ÿä', 'gold',
    'ŸÅÿ∂Ÿä', 'silver', 'ŸÉÿ≠ŸÑŸä', 'navy', 'ÿ≤Ÿáÿ±Ÿä', 'ÿ®Ÿäÿ¨', 'beige'
  ]
  
  // Common sizes with Arabic mappings
  const sizeMap = {
    'ÿßŸÉÿ≥ ÿ≥ŸÖŸàŸÑ': 'xs', 'ÿßŸÉÿ≥ ÿßÿ≥': 'xs', 'xs': 'xs', 'x-small': 'xs',
    'ÿ≥ŸÖŸàŸÑ': 's', 'ÿµÿ∫Ÿäÿ±': 's', 's': 's', 'small': 's',
    'ŸÖŸäÿØŸäŸÖ': 'm', 'ŸÖÿ™Ÿàÿ≥ÿ∑': 'm', 'Ÿàÿ≥ÿ∑': 'm', 'm': 'm', 'medium': 'm',
    'ŸÑÿßÿ±ÿ¨': 'l', 'ŸÉÿ®Ÿäÿ±': 'l', 'l': 'l', 'large': 'l',
    'ÿßŸÉÿ≥ ŸÑÿßÿ±ÿ¨': 'xl', 'ÿßŸÉÿ≥ ÿßŸÑ': 'xl', 'xl': 'xl', 'x-large': 'xl',
    'ÿßŸÉÿ≥ ÿßŸÉÿ≥ ŸÑÿßÿ±ÿ¨': 'xxl', 'ÿßŸÉÿ≥ ÿßŸÉÿ≥ ÿßŸÑ': 'xxl', 'xxl': 'xxl', '2xl': 'xxl',
    'ÿßŸÉÿ≥ ÿßŸÉÿ≥ ÿßŸÉÿ≥ ŸÑÿßÿ±ÿ¨': 'xxxl', 'xxxl': 'xxxl', '3xl': 'xxxl'
  }
  const sizes = Object.keys(sizeMap)
  
  let foundColor = null
  let foundSize = null
  let productName = normalizedText
  
  // Extract color
  for (const color of colors) {
    const regex = new RegExp(`\\b${color}\\b`, 'gi')
    if (regex.test(normalizedText)) {
      foundColor = color
      productName = productName.replace(regex, '').trim()
      break
    }
  }
  
  // Extract size with Arabic support
  for (const size of sizes) {
    const regex = new RegExp(`\\b${size}\\b`, 'gi')
    if (regex.test(productName)) {
      foundSize = sizeMap[size.toLowerCase()] || size
      productName = productName.replace(regex, '').trim()
      break
    }
  }
  
  // Clean up product name
  productName = productName.replace(/\s+/g, ' ').trim()
  
  return {
    name: productName,
    color: foundColor,
    size: foundSize
  }
}

// Extract phone number from recent messages context
async function extractPhoneFromContext(chatId: number): Promise<string> {
  // Try to get phone from pending orders map first
  const pendingOrder = pendingOrders.get(chatId)
  if (pendingOrder && pendingOrder.customerPhone) {
    return pendingOrder.customerPhone
  }
  
  // Fallback to a placeholder
  return '07xxxxxxxx'
}

// Generate stock alert message like the example provided
function generateStockAlert(product: any, details: any, phone: string, variant?: any): string {
  const productName = product.name
  const colorText = details.color ? details.color : 'ÿ®ÿØŸàŸÜ ŸÑŸàŸÜ'
  const sizeText = details.size ? details.size : ''
  
  return `‚ö†Ô∏è ÿ™ŸÜÿ®ŸäŸá ÿ™ŸàŸÅÿ±
üì± ÿßŸÑŸáÿßÿ™ŸÅ : ${phone}
‚ùå ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ${productName} ${colorText} ${sizeText} √ó 1 ‚Äî ÿ®ÿØŸàŸÜ ŸÑŸàŸÜ

‚ö†Ô∏è ÿ®ÿπÿ∂ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ© ÿ≠ÿßŸÑŸäÿßŸã ÿ£Ÿà ŸÖÿ≠ÿ¨Ÿàÿ≤ÿ©. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿ®ÿØŸäŸÑ ÿØÿßÿÆŸÑ ÿßŸÑŸÖŸàŸÇÿπ ŸÇÿ®ŸÑ ÿßŸÑŸÖŸàÿßŸÅŸÇÿ©`
}

// Smart city finder using cache system with fuzzy matching
async function findCityByNameSmart(cityName: string): Promise<{ city: any | null, suggestions: any[], confidence: number }> {
  try {
    // Use the smart cache system for primary search
    const { data: cityMatches, error } = await supabase.rpc('find_city_in_cache', {
      p_city_text: cityName
    })
    
    if (!error && cityMatches && cityMatches.length > 0) {
      const bestMatch = cityMatches[0]
      if (bestMatch.similarity_score >= 0.7) {
        console.log(`üèôÔ∏è Ÿàÿ¨ÿØÿ™ ŸÖÿØŸäŸÜÿ© ÿ∞ŸÉŸäÿ©: ${bestMatch.name} (${bestMatch.similarity_score})`)
        return { 
          city: { id: bestMatch.alwaseet_id, name: bestMatch.name, original_id: bestMatch.alwaseet_id }, 
          suggestions: [], 
          confidence: bestMatch.similarity_score 
        }
      }
    }
    
    // Fallback to local cache
    const cities = await getCitiesFromCache()
    const normalizedName = normalizeArabic(cityName)
    
    if (!cities.length) {
      return { city: null, suggestions: [], confidence: 0 }
    }
    
    let bestCity = null
    let bestScore = 0
    const allMatches = []
    
    // Direct and variation matching with scoring
    for (const city of cities) {
      const cityNormalized = normalizeArabic(city.name)
      let score = calculateSimilarity(normalizedName, cityNormalized)
      
      // Check variations with improved logic
      const foundCity = findCityByVariation(cityName)
      if (foundCity) {
        const standardNormalized = normalizeArabic(foundCity)
        if (cityNormalized.includes(standardNormalized) || standardNormalized.includes(cityNormalized)) {
          score = Math.max(score, 0.95)
        }
      }
      
      if (score >= 0.7) {
        allMatches.push({ city, score })
        if (score > bestScore) {
          bestScore = score
          bestCity = city
        }
      } else if (score >= 0.5) {
        // Lower confidence suggestions
        allMatches.push({ city, score })
      }
    }
    
    // Sort matches by score
    allMatches.sort((a, b) => b.score - a.score)
    const suggestions = allMatches.slice(1, 4) // Top 3 alternatives
    
    return { 
      city: bestCity, 
      suggestions: suggestions.map(m => m.city), 
      confidence: bestScore 
    }
  } catch (error) {
    console.error('Error in smart city search:', error)
    return { city: null, suggestions: [], confidence: 0 }
  }
}

// Parse address to extract city, region, and address details with smart matching
async function parseAddressWithSmartMatching(addressText: string): Promise<{
  city: any | null,
  region: any | null,
  fullAddress: string,
  confidence: number
}> {
  try {
    console.log(`üè† ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿπŸÜŸàÿßŸÜ: "${addressText}"`)
    
    // Split the address into parts
    const addressParts = addressText.split(/[,ÿå\n]/).map(part => part.trim()).filter(Boolean)
    
    let foundCity = null
    let foundRegion = null
    let confidence = 0
    let remainingAddress = addressText
    
    // Try to identify city from address parts
    for (const part of addressParts) {
      const cityResult = await findCityByNameSmart(part)
      if (cityResult.city && cityResult.confidence > confidence) {
        foundCity = cityResult.city
        confidence = cityResult.confidence
        remainingAddress = remainingAddress.replace(part, '').trim()
        console.log(`üèôÔ∏è ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿØŸäŸÜÿ©: ${foundCity.name} (${confidence})`)
        break
      }
    }
    
    // If city found, try to find region
    if (foundCity) {
      const regions = await getRegionsByCity(foundCity.id)
      
      for (const part of addressParts) {
        const normalizedPart = normalizeArabic(part)
        
        for (const region of regions) {
          const regionNormalized = normalizeArabic(region.name)
          const similarity = calculateSimilarity(normalizedPart, regionNormalized)
          
          if (similarity >= 0.7) {
            foundRegion = region
            remainingAddress = remainingAddress.replace(part, '').trim()
            console.log(`üó∫Ô∏è ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©: ${region.name} (${similarity})`)
            break
          }
        }
        
        if (foundRegion) break
      }
    }
    
    // Clean up remaining address
    remainingAddress = remainingAddress
      .replace(/[,ÿå]+/g, ', ')
      .replace(/\s+/g, ' ')
      .trim()
      .replace(/^[,ÿå\s]+|[,ÿå\s]+$/g, '')
    
    return {
      city: foundCity,
      region: foundRegion,
      fullAddress: remainingAddress || addressText,
      confidence
    }
  } catch (error) {
    console.error('Error parsing address:', error)
    return {
      city: null,
      region: null,
      fullAddress: addressText,
      confidence: 0
    }
  }
}

// Get employee information by telegram chat ID with fallback methods
async function getEmployeeByTelegramId(chatId: number) {
  try {
    console.log(`üîç ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖŸàÿ∏ŸÅ ÿ®ŸÄ chat ID: ${chatId}`)
    
    // Use the new RPC function
    const { data, error } = await supabase.rpc('find_employee_by_telegram_chat_id', {
      p_chat_id: chatId
    })
    
    if (!error && data?.success) {
      console.log(`üë§ ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖŸàÿ∏ŸÅ: ${data.employee_code} - ${data.full_name}`)
      return {
        employee_code: data.employee_code,
        full_name: data.full_name,
        user_id: data.user_id,
        telegram_chat_id: data.chat_id,
        role_title: 'ŸÖŸàÿ∏ŸÅ', // Default role
        is_active: true
      }
    }
    
    console.log('‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖŸàÿ∏ŸÅ ŸÑŸÑŸÄ chat ID:', chatId)
    return null
  } catch (error) {
    console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖŸàÿ∏ŸÅ:', error)
    return null
  }
}

// Link employee code to telegram chat ID
async function linkEmployeeCode(employeeCode: string, chatId: number): Promise<boolean> {
  try {
    const { data, error } = await supabase.rpc('link_employee_telegram_code', {
      p_employee_code: employeeCode,
      p_chat_id: chatId
    })
    
    if (!error && data?.success) {
      console.log('Successfully linked employee code:', employeeCode)
      return true
    }
    
    console.error('Failed to link employee code:', error || data?.message)
    return false
  } catch (error) {
    console.error('Error linking employee code:', error)
    return false
  }
}

// Process order text and save to ai_orders (updated to work with new function)
async function processOrderText(text: string, chatId: number, employeeData: any): Promise<boolean> {
  try {
    console.log(`üìù ŸÖÿπÿßŸÑÿ¨ÿ© ŸÜÿµ ÿßŸÑÿ∑ŸÑÿ®: "${text}"`)
    console.log(`üë§ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖŸàÿ∏ŸÅ:`, employeeData)
    
    const lines = text.split('\n').filter(line => line.trim())
    
    if (lines.length < 2) {
      console.log('‚ùå ÿßŸÑÿ∑ŸÑÿ® ŸÇÿµŸäÿ± ÿ¨ÿØÿßŸã - Ÿäÿ≠ÿ™ÿßÿ¨ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≥ÿ∑ÿ±ŸäŸÜ')
      await sendTelegramMessage(chatId, `‚ùå ÿßŸÑÿ∑ŸÑÿ® Ÿäÿ≠ÿ™ÿßÿ¨ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≥ÿ∑ÿ±ŸäŸÜ: ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ≤ÿ®ŸàŸÜ ŸàÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™

üìù ŸÖÿ´ÿßŸÑ ÿµÿ≠Ÿäÿ≠:
ÿ£ÿ≠ŸÖÿØ ÿπŸÑŸä
07712345678
ÿØŸäŸàÿßŸÜŸäÿ© ÿ∫ŸÖÿßÿ≥
ÿ®ÿ±ÿ¥ŸÑŸàŸÜÿ© ÿßÿ≤ÿ±ŸÇ ŸÑÿßÿ±ÿ¨`)
      return false
    }
    
    // Extract customer information
    let customerName = ''
    let customerPhone = ''
    let customerAddress = ''
    let customerCity = ''
    let products: any[] = []
    
    // Parse each line
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim()
      
      // Phone number pattern
      if (/^0?7[5-9]\d{8}$/.test(line.replace(/[\s-]/g, ''))) {
        customerPhone = line.replace(/[\s-]/g, '')
        continue
      }
      
      // If it's the first line and no phone found yet, assume it's customer name
      if (i === 0 && !customerName && !/^0?7[5-9]\d{8}$/.test(line)) {
        customerName = line
        continue
      }
      
      // Check if it's a product line (has arabic letters and possibly size/color info)
      if (/[ÿß-Ÿä]/.test(line) && (line.includes('L') || line.includes('M') || line.includes('S') || line.includes('XL') || /\b(ÿßÿ≠ŸÖÿ±|ÿßÿ≤ÿ±ŸÇ|ÿßÿ≥ŸàÿØ|ÿßÿ®Ÿäÿ∂|ÿßÿÆÿ∂ÿ±|ÿßÿµŸÅÿ±|Ÿàÿ±ÿØŸä|ÿ®ŸÜŸä|ÿ±ŸÖÿßÿØŸä)\b/.test(line))) {
        // This looks like a product
        const productSearch = await searchProductWithVariantsAndInventory(line, chatId, customerPhone)
        
        if (productSearch.found) {
          if (productSearch.available && productSearch.product) {
            products.push({
              name: productSearch.product.name,
              color: productSearch.variant?.color?.name || 'ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä',
              size: productSearch.variant?.size?.name || 'ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä',
              quantity: 1,
              price: productSearch.product.price || 0
            })
          } else if (productSearch.stockAlert) {
            // Send stock alert
            await sendTelegramMessage(chatId, productSearch.stockAlert)
            return false
          }
        }
        continue
      }
      
      // Everything else is address information
      if (!customerAddress) {
        customerAddress = line
        
        // Try to parse city from address
        const addressInfo = await parseAddressWithSmartMatching(line)
        if (addressInfo.city) {
          customerCity = addressInfo.city.name
        }
      } else {
        customerAddress += ' ' + line
      }
    }
    
    // Validate required fields
    if (!customerName) {
      customerName = employeeData.full_name || 'ÿ≤ÿ®ŸàŸÜ ŸÖŸÜ ÿßŸÑÿ™ŸÑŸäÿ∫ÿ±ÿßŸÖ'
    }
    
    if (!customerPhone || products.length === 0) {
      console.log('‚ùå ÿ®ŸäÿßŸÜÿßÿ™ ŸÜÿßŸÇÿµÿ© - ŸÑÿß ŸäŸàÿ¨ÿØ Ÿáÿßÿ™ŸÅ ÿ£Ÿà ŸÖŸÜÿ™ÿ¨ÿßÿ™')
      await sendTelegramMessage(chatId, `‚ùå ÿßŸÑÿ∑ŸÑÿ® Ÿäÿ≠ÿ™ÿßÿ¨ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ÿ≥ÿ∑ÿ±ŸäŸÜ: ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ≤ÿ®ŸàŸÜ ŸàÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™

üìù ŸÖÿ´ÿßŸÑ ÿµÿ≠Ÿäÿ≠:
ÿ£ÿ≠ŸÖÿØ ÿπŸÑŸä
07712345678
ÿØŸäŸàÿßŸÜŸäÿ© ÿ∫ŸÖÿßÿ≥
ÿ®ÿ±ÿ¥ŸÑŸàŸÜÿ© ÿßÿ≤ÿ±ŸÇ ŸÑÿßÿ±ÿ¨`)
      return false
    }
    
    // Calculate total amount
    const totalAmount = products.reduce((sum, product) => sum + (product.price * product.quantity), 0)
    
    // Create order data structure
    const orderData = {
      customer_name: customerName,
      customer_phone: customerPhone,
      customer_address: customerAddress,
      customer_city: customerCity,
      delivery_type: 'ÿ™ŸàÿµŸäŸÑ',
      items: products,
      total_amount: totalAmount,
      source: 'telegram',
      employee_code: employeeData.employee_code
    }
    
    console.log(`üìã ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©:`, orderData)
    
    // Call the process_telegram_order function with the correct parameters
    const { data: result, error } = await supabase.rpc('process_telegram_order', {
      p_order_text: text,
      p_chat_id: chatId,
      p_employee_code: employeeData.employee_code
    })
    
    if (error) {
      console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßÿ≥ÿ™ÿØÿπÿßÿ° process_telegram_order:', error)
      await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ∑ŸÑÿ® ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
      return false
    }
    
    if (result?.success) {
      console.log('‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑÿ∞ŸÉŸä ÿ®ŸÜÿ¨ÿßÿ≠')
      await sendTelegramMessage(chatId, `‚úÖ ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠!
      
üë§ ÿßŸÑÿπŸÖŸäŸÑ: ${customerName}
üì± ÿßŸÑŸáÿßÿ™ŸÅ: ${customerPhone}
üìç ÿßŸÑÿπŸÜŸàÿßŸÜ: ${customerAddress}
üì¶ ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™: ${products.length} ŸÇÿ∑ÿπÿ©
üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä: ${totalAmount.toLocaleString()} ÿØŸäŸÜÿßÿ±

ÿ≥Ÿäÿ™ŸÖ ŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑÿ∑ŸÑÿ® ŸàÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÉ ŸÇÿ±Ÿäÿ®ÿßŸã.`)
      return true
    } else {
      console.log('‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ∑ŸÑÿ® ÿßŸÑÿ∞ŸÉŸä:', result?.message)
      await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ∑ŸÑÿ® ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
      return false
    }
    
  } catch (error) {
    console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ŸÜÿµ ÿßŸÑÿ∑ŸÑÿ®:', error)
    await sendTelegramMessage(chatId, '‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ∑ŸÑÿ® ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
    return false
  }
}

// Main serve function
serve(async (req) => {
  console.log('üî¥ Telegram webhook called!')
  console.log('Request URL:', req.url)
  console.log('Request method:', req.method)

  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const update: TelegramUpdate = await req.json()
    console.log('Received update:', JSON.stringify(update, null, 2))

    if (!update.message?.text) {
      return new Response('OK', { status: 200, headers: corsHeaders })
    }

    const chatId = update.message.chat.id
    const messageText = update.message.text.trim()

    console.log(`Processing message from chatId: ${chatId}, text: "${messageText}"`)

    // Check if user is linked
    const employee = await getEmployeeByTelegramId(chatId)

    if (!employee) {
      // User not linked - try to link with employee code
      const codePattern = /^[A-Z]{3}\d{3,4}$/i
      if (codePattern.test(messageText)) {
        const success = await linkEmployeeCode(messageText.toUpperCase(), chatId)
        if (success) {
          const newEmployee = await getEmployeeByTelegramId(chatId)
          if (newEmployee) {
            await sendTelegramMessage(chatId, `‚úÖ ÿ™ŸÖ ÿ±ÿ®ÿ∑ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠!
            
üë§ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸàÿ∏ŸÅ: ${newEmployee.full_name}
üè¢ ÿßŸÑŸÖŸÜÿµÿ®: ${newEmployee.role_title}
üÜî ŸÉŸàÿØ ÿßŸÑŸÖŸàÿ∏ŸÅ: ${newEmployee.employee_code}

ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™. ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿßÿ≥ŸÖ ÿßŸÑÿπŸÖŸäŸÑ
ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ
ÿßŸÑÿπŸÜŸàÿßŸÜ
ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ + ÿßŸÑŸÑŸàŸÜ + ÿßŸÑŸÖŸÇÿßÿ≥`)
          }
        } else {
          await sendTelegramMessage(chatId, `‚ùå ŸÉŸàÿØ ÿßŸÑŸÖŸàÿ∏ŸÅ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠: ${messageText}
          
ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑŸÉŸàÿØ ŸàÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.`)
        }
      } else {
        await sendTelegramMessage(chatId, `ŸÖÿ±ÿ≠ÿ®ÿßŸã! üëã

ŸÑŸÑÿ®ÿØÿ°ÿå Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸàÿØ ÿßŸÑŸÖŸàÿ∏ŸÅ ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ.
ŸÖÿ´ÿßŸÑ: ABC123

ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÖŸÑŸÉ ŸÉŸàÿØ ŸÖŸàÿ∏ŸÅÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ•ÿØÿßÿ±ÿ©.`)
      }
      
      return new Response('OK', { status: 200, headers: corsHeaders })
    }

    console.log('Employee found:', employee)
    console.log(`Processing order for employee: ${employee.employee_code}`)
    console.log(`üìù ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÑÿ≤ÿ®ŸàŸÜ: ${employee.full_name}`)

    // Handle commands
    if (messageText === '/start' || messageText === '/help') {
      await sendTelegramMessage(chatId, `ŸÖÿ±ÿ≠ÿ®ÿßŸã ${employee.full_name}! üëã

ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿ®ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿßÿ≥ŸÖ ÿßŸÑÿπŸÖŸäŸÑ
ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ
ÿßŸÑÿπŸÜŸàÿßŸÜ
ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨ + ÿßŸÑŸÑŸàŸÜ + ÿßŸÑŸÖŸÇÿßÿ≥

ŸÖÿ´ÿßŸÑ:
ÿ£ÿ≠ŸÖÿØ ÿπŸÑŸä
07712345678
ÿØŸäŸàÿßŸÜŸäÿ© ÿ∫ŸÖÿßÿ≥
ÿ®ÿ±ÿ¥ŸÑŸàŸÜÿ© ÿßÿ≤ÿ±ŸÇ ŸÑÿßÿ±ÿ¨`)
      
      return new Response('OK', { status: 200, headers: corsHeaders })
    }

    if (messageText === '/stats') {
      // Get employee stats
      const { data: stats } = await supabase
        .from('ai_orders')
        .select('id, status, created_at')
        .eq('created_by', employee.employee_code)
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())

      const totalOrders = stats?.length || 0
      const processedOrders = stats?.filter(o => o.status === 'processed').length || 0
      const pendingOrders = stats?.filter(o => o.status === 'pending').length || 0

      await sendTelegramMessage(chatId, `üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ŸÉ ÿÆŸÑÿßŸÑ ÿ¢ÿÆÿ± 30 ŸäŸàŸÖ:

üì¶ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™: ${totalOrders}
‚úÖ ÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿπÿßŸÑÿ¨ÿ©: ${processedOrders}
‚è≥ ÿ∑ŸÑÿ®ÿßÿ™ ŸÅŸä ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±: ${pendingOrders}`)
      
      return new Response('OK', { status: 200, headers: corsHeaders })
    }

    // Process as order
    const success = await processOrderText(messageText, chatId, employee)
    
    if (!success) {
      console.log('üö® ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿ∑ÿ£: incomplete_order')
    }

    return new Response('OK', { status: 200, headers: corsHeaders })

  } catch (error) {
    console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© webhook:', error)
    return new Response('Internal Server Error', { 
      status: 500, 
      headers: corsHeaders 
    })
  }
})